{"add_chunk_ticket":{"signatures":[{"params":[{"name":"pos"},{"name":"type"},{"name":"radius"}]}],"docs":"Adds a chunk ticket at a position, which makes the game to keep the designated area centered around\n`pos` with radius of `radius` loaded for a predefined amount of ticks, defined by `type`. Allowed types\nare `portal`: 300 ticks, `teleport`: 5 ticks, and `unknown`: 1 tick. Radius can be from 1 to 32 ticks.\n\nThis function is tentative - will likely change when chunk ticket API is properly fleshed out."},"air":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if a block is air... or cave air... or void air... or any other air they come up with."},"biome":{"signatures":[{"params":[]},{"params":[{"name":"name_or_block"}]},{"params":[{"name":"name_or_block"},{"name":"feature"}]},{"params":"noise_map"}],"docs":"Without arguments, returns the list of biomes in the world.\n\nWith block, or name, returns the name of the biome in that position, or throws `'unknown_biome'` if provided biome or block are not valid.\n\n(1.18+) if passed a map of `continentalness`, `depth`, `erosion`, `humidity`, `temperature`, `weirdness`, returns the biome that exists at those noise values.\nNote: Have to pass all 6 of the mentioned noise types and only these noise types for it to evaluate a biome.\n\nWith an optional feature, it returns value for the specified attribute for that biome. Available and queryable features include:\n* `'top_material'`: unlocalized block representing the top surface material (1.17.1 and below only)\n* `'under_material'`: unlocalized block representing what sits below topsoil (1.17.1 and below only)\n* `'category'`: the parent biome this biome is derived from. Possible values include (1.18.2 and below only):\n`'none'`, `'taiga'`, `'extreme_hills'`, `'jungle'`, `'mesa'`, `'plains'`, `'savanna'`,\n`'icy'`, `'the_end'`, `'beach'`, `'forest'`, `'ocean'`, `'desert'`, `'river'`,\n`'swamp'`, `'mushroom'` , `'nether'`, `'underground'` (1.18+) and `'mountain'` (1.18+).\n* `'tags'`: list of biome tags associated with this biome\n* `'temperature'`: temperature from 0 to 1\n* `'fog_color'`: RGBA color value of fog\n* `'foliage_color'`: RGBA color value of foliage\n* `'sky_color'`: RGBA color value of sky\n* `'water_color'`: RGBA color value of water\n* `'water_fog_color'`: RGBA color value of water fog\n* `'humidity'`: value from 0 to 1 indicating how wet is the biome\n* `'precipitation'`: `'rain'` `'snot'`, or `'none'`... ok, maybe `'snow'`, but that means snots for sure as well.\n* `'depth'`: (1.17.1 and below only) float value indicating how high or low the terrain should generate. Values > 0 indicate generation above sea level\nand values < 0, below sea level.\n* `'scale'`: (1.17.1 and below only) float value indicating how flat is the terrain.\n* `'features'`: list of features that generate in the biome, grouped by generation steps\n* `'structures'`: (1.17.1 and below only) list of structures that generate in the biome."},"blast_resistance":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, indicating blast_resistance of a block."},"block":{"signatures":[{"params":[{"name":"x"},{"name":"y"},{"name":"z"}]},{"params":[{"name":"pos"}]},{"params":[{"name":"state"}]}],"docs":"Returns either a block from specified location, or block with a specific state (as used by `/setblock` command),\nso allowing for block properties, block entity data etc. Blocks otherwise can be referenced everywhere by its simple\nstring name, but its only used in its default state.\n\n```scarpet\nblock('air')  => air\nblock('iron_trapdoor[half=top]')  => iron_trapdoor\nblock(0,0,0) == block('bedrock')  => 1\nblock('hopper[facing=north]{Items:[{Slot:1b,id:\"minecraft:slime_ball\",Count:16b}]}') => hopper\n```\n\nRetrieving a block with `block` function has also a side-effect of evaluating its current state and data.\nSo if you use it later it will reflect block state and data of the block that was when block was called, rather than\nwhen it was used. Block values passed in various places like `scan` functions, etc, are not fully evaluated unless\nits properties are needed. This means that if the block at the location changes before its queried in the program this\nmight result in getting the later state, which might not be desired. Consider the following example:\n\nThrows `unknown_block` if provided input is not valid.\n\n```scarpet\nset(10,10,10,'stone');\nscan(10,10,10,0,0,0, b = _);\nset(10,10,10,'air');\nprint(b); // 'air', block was remembered 'lazily', and evaluated by `print`, when it was already set to air\nset(10,10,10,'stone');\nscan(10,10,10,0,0,0, b = block(_));\nset(10,10,10,'air');\nprint(b); // 'stone', block was evaluated 'eagerly' but call to `block`\n```"},"block_data":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Return NBT string associated with specific location, or null if the block does not carry block data. Can be currently\nused to match specific information from it, or use it to copy to another block\n\n```scarpet\nblock_data(x,y,z) => '{TransferCooldown:0,x:450,y:68, ... }'\n```"},"block_light":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning the block light at position (from torches and other light sources)."},"block_list":{"signatures":[{"params":[]},{"params":[{"name":"tag"}]}],"docs":"Returns list of all blocks in the game. If `tag` is provided, returns list of all blocks that belong to this block tag.\n```scarpet\nblock_list() => [dark_oak_button, wall_torch, structure_block, polished_blackstone_brick_slab, cherry_sapling... ]\nblock_list('impermeable') => [glass, white_stained_glass, orange_stained_glass, magenta_stained_glass... ] //All da glass\nblock_list('rails') => [rail, powered_rail, detector_rail, activator_rail]\nblock_list('not_a_valid_block_tag') => null //Not a valid block tag\n```"},"block_properties":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Deprecated by `keys(block_state(pos))`."},"block_sound":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns the name of sound type made by the block at position. One of:\n\n`'wood'`, `'gravel'`, `'grass'`, `'stone'`, `'metal'`, `'glass'`, `'wool'`, `'sand'`, `'snow'`,\n`'ladder'`, `'anvil'`, `'slime'`, `'sea_grass'`, `'coral'`, `'bamboo'`', `'shoots'`', `'scaffolding'`', `'berry'`', `'crop'`',\n`'stem'`', `'wart'`',\n`'lantern'`', `'fungi_stem'`', `'nylium'`', `'fungus'`', `'roots'`', `'shroomlight'`', `'weeping_vines'`', `'soul_sand'`',\n `'soul_soil'`', `'basalt'`',\n`'wart'`', `'netherrack'`', `'nether_bricks'`', `'nether_sprouts'`', `'nether_ore'`', `'bone'`', `'netherite'`', `'ancient_debris'`',\n`'lodestone'`', `'chain'`', `'nether_gold_ore'`', `'gilded_blackstone'`',\n`'candle'`', `'amethyst'`', `'amethyst_cluster'`', `'small_amethyst_bud'`', `'large_amethyst_bud'`', `'medium_amethyst_bud'`',\n`'tuff'`', `'calcite'`', `'copper'`'"},"block_state":{"signatures":[{"params":[{"name":"block"}]},{"params":[{"name":"block"},{"name":"property"}]}],"docs":", `block_state(block, property)`\n\nIf used with a `block` argument only, it returns a map of block properties and their values.  If a block has no properties, returns an\nempty map.\n\nIf `property` is specified, returns a string value of that property, or `null` if property is not applicable.\n\nReturned values or properties are always strings. It is expected from the user to know what to expect and convert\nvalues to numbers using `number()` function or booleans using `bool()` function. Returned string values can be directly used\nback in state definition in various applications where block properties are required.\n\n`block_state` can also accept block names as input, returning block's default state.\n\nThrows `unknown_block` if the provided input is not valid.\n\n```scarpet\nset(x,y,z,'iron_block'); block_state(x,y,z)  => {}\nset(x,y,z,'iron_trapdoor','half','top'); block_state(x,y,z)  => {waterlogged: false, half: top, open: false, ...}\nset(x,y,z,'iron_trapdoor','half','top'); block_state(x,y,z,'half')  => top\nblock_state('iron_trapdoor','half')  => top\nset(x,y,z,'air'); block_state(x,y,z,'half')  => null\nblock_state(block('iron_trapdoor[half=top]'),'half')  => top\nblock_state(block('iron_trapdoor[half=top]'),'powered')  => false\nbool(block_state(block('iron_trapdoor[half=top]'),'powered'))  => 0\n```"},"block_tags":{"signatures":[{"params":[]},{"params":[{"name":"block"}]},{"params":[{"name":"block"},{"name":"tag"}]}],"docs":", `block_tags(block)`, `block_tags(block, tag)`\n\nWithout arguments, returns list of available tags, with block supplied (either by coordinates, or via block name), returns lost\nof tags the block belongs to, and if a tag is specified, returns `null` if tag is invalid, `false` if this block doesn't belong\nto this tag, and `true` if the block belongs to the tag.\n\nThrows `unknown_block` if `block` doesn't exist\n\n```scarpet\nblock_tags() => [geode_invalid_blocks, wall_post_override, ice, wooden_stairs, bamboo_blocks, stone_bricks... ]\nblock_tags('iron_block') => [mineable/pickaxe, needs_stone_tool, beacon_base_blocks]\nblock_tags('glass') => [impermeable]\nblock_tags('glass', 'impermeable') => true\nblock_tags('glass', 'beacon_base_blocks') => false\n```"},"block_tick":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Causes a block to tick at position."},"blocks_daylight":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block blocks daylight."},"blocks_movement":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block at position blocks movement."},"crafting_remaining_item":{"signatures":[{"params":[{"name":"item"}]}],"docs":"returns `null` if the item has no remaining item in the crafting window when used as a crafting ingredient, or an\nitem name that serves as a replacement after crafting is done. Currently it can only be buckets and glass bottles."},"create_explosion":{"signatures":[{"params":[{"name":"pos"},{"name":"power"},{"name":"mode"},{"name":"fire"},{"name":"source"},{"name":"attacker"}]}],"docs":"Creates an explosion at a given position. Parameters work as follows:\n - `'power'` - how strong the blast is, negative values count as 0 (default: `4` (TNT power))\n - `'mode'` - how to deal with broken blocks: `keep` keeps them, `destroy` destroys them and drops items, and `destroy_with_decay` destroys them, but doesn't always drop the items (default: `destroy_with_decay`)\n - `fire` - whether extra fire blocks should be created (default: `false`)\n - `source` - entity that is exploding. Note that it will not take explosion damage from this explosion (default: `null`)\n - `attacker` - entity responsible for triggering, this will be displayed in death messages, and count towards kill counts, and can be damaged by the explosion (default: `null`)\nExplosions created with this endpoint cannot be captured with `__on_explosion` event, however they will be captured\nby `__on_explosion_outcome`."},"destroy":{"signatures":[{"params":[{"name":"pos"},{"name":"destroypos"},{"name":"1"},{"name":"destroypos"},{"name":"N"},{"name":"destroypos"},{"name":"tool"},{"name":"nbt"}]}],"docs":"Destroys the block like it was mined by a player. Add -1 for silk touch, and a positive number for fortune level.\nIf tool is specified, and optionally its nbt, it will use that tool and will attempt to mine the block with this tool.\nIf called without item context, this function, unlike harvest, will affect all kinds of blocks. If called with item\nin context, it will fail to break blocks that cannot be broken by a survival player.\n\nWithout item context it returns `false` if failed to destroy the block and `true` if block breaking was successful.\nIn item context, `true` means that breaking item has no nbt to use, `null` indicating that the tool should be\nconsidered broken in process, and `nbt` type value, for a resulting NBT tag on a hypothetical tool. Its up to the\nprogrammer to use that nbt to apply it where it belong\n\nThrows `unknown_item` if `tool` doesn't exist.\n\nHere is a sample code that can be used to mine blocks using items in player inventory, without using player context\nfor mining. Obviously, in this case the use of `harvest` would be much more applicable:\n\n```scarpet\nmine(x,y,z) ->\n(\n  p = player();\n  slot = p~'selected_slot';\n  item_tuple = inventory_get(p, slot);\n  if (!item_tuple, destroy(x,y,z,'air'); return()); // empty hand, just break with 'air'\n  [item, count, tag] = item_tuple;\n  tag_back = destroy(x,y,z, item, tag);\n  if (tag_back == false, // failed to break the item\n    return(tag_back)\n  );\n  if (tag_back == true, // block broke, tool has no tag\n    return(tag_back)\n  );\n  if (tag_back == null, //item broke\n    delete(tag:'Damage');\n    inventory_set(p, slot, count-1, item, tag);\n    return(tag_back)\n  );\n  if (type(tag_back) == 'nbt', // item didn't break, here is the effective nbt\n    inventory_set(p, slot, count, item, tag_back);\n    return(tag_back)\n  );\n  print('How did we get here?');\n)\n```"},"diamond":{"signatures":[{"params":[{"name":"center_pos"},{"name":"radius"},{"name":"height"}]}],"docs":"Iterates over a diamond like area of blocks. With no radius and height, its 7 blocks centered around the middle\n(block + neighbours). With a radius specified, it expands shape on x and z coords, and with a custom height, on y.\nAny of these can be zero as well. radius of 0 makes a stick, height of 0 makes a diamond shape pad.\n\nIf radius and height are the same, creats a 3D diamond, of all the blocks which are a manhattan distance of `radius` away\nfrom the center."},"drop_item":{"signatures":[{"params":[{"name":"inventory"},{"name":"slot"},{"name":"amount"},{"name":""}]}],"docs":"Drops the items from indicated inventory slot, like player that Q's an item or villager, that exchanges food.\nYou can Q items from block inventories as well. default amount is 0 - which is all from the slot.\nNOTE: hoppers are quick enough to pick all the queued items from their inventory anyways.\nReturns size of the actual dropped items.\n\n```scarpet\ninventory_drop(player(), 0, 1) => 1 // Q's one item on the ground\ninventory_drop(x,y,z, 0) => 64 // removed and spawned in the world a full stack of items\n```"},"effective_light":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning the \"real\" light at position, which is affected by time and weather. which also affects mobs spawning, frosted ice blocks melting."},"emitted_light":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning the light level emitted from the block."},"entity_area":{"signatures":[{"params":[{"name":"type"},{"name":"center"},{"name":"distance"}]}],"docs":"Returns entities of a specified type in an area centered on `center` and at most `distance` blocks away from\nthe center point/area. Uses the same `type` selectors as `entities_list`.\n\n`center` and `distance` can either be a triple of coordinates or three consecutive arguments for `entity_area`. `center` can\nalso be represented as a block, in this case the search box will be centered on the middle of the block, or an entity - in this case\nentire bounding box of the entity serves as a 'center' of search which is then expanded in all directions with the `'distance'` vector.\n\nIn any case - returns all entities which bounding box collides with the bounding box defined by `'center'` and `'distance'`.\n\nentity_area is simpler than `entity_selector` and runs about 20% faster, but is limited to predefined selectors and\ncuboid search area."},"entity_event":{"signatures":[{"params":[{"name":"e"},{"name":"event"},{"name":"function"}]}],"docs":", `entity_event(e, event, call_name, ... args?)`\n\nAttaches specific function from the current package to be called upon the `event`, with extra `args` carried to the\noriginal required arguments for the event handler.\n\n```scarpet\nprotect_villager(entity, amount, source, source_entity, healing_player) ->\n(\n   if(source_entity && source_entity~'type' != 'player',\n      modify(entity, 'health', amount + entity~'health' );\n      particle('end_rod', pos(entity)+[0,3,0]);\n      print(str('%s healed thanks to %s', entity, healing_player))\n   )\n);\n__on_player_interacts_with_entity(player, entity, hand) ->\n(\n   if (entity~'type' == 'villager',\n      entity_event(entity, 'on_damage', 'protect_villager', player~'name')\n   )\n)\n```\n\nIn this case this will protect a villager from entity damage (zombies, etc.) except from players by granting all the\nhealth back to the villager after being harmed."},"entity_id":{"signatures":[{"params":[{"name":"uuid"},{"name":"entity_idid"}]}],"docs":"Fetching entities either by their ID obtained via `entity ~ 'id'`, which is unique for a dimension and current world\nrun, or by UUID, obtained via `entity ~ 'uuid'`. It returns null if no such entity is found. Safer way to 'store'\nentities between calls, as missing entities will be returning `null`. Both calls using UUID or numerical ID are `O(1)`,\nbut obviously using UUIDs takes more memory and compute."},"entity_list":{"signatures":[{"params":[{"name":"descriptor"}]}],"docs":"Returns global lists of entities in the current dimension matching specified descriptor.\nCalls to `entity_list` always fetch entities from the current world that the script executes."},"entity_load_handler":{"signatures":[{"params":[{"name":"descriptordescriptors"},{"name":"function"}]}],"docs":", `entity_load_handler(descriptor / descriptors, call_name, ... args?)`\n\nAttaches a callback to trigger when any entity matching the following type / types is loaded in the game, allowing to grab a handle\nto an entity right when it is loaded to the world without querying them every tick. Callback expects two parameters - the entity,\nand a boolean value indicating if the entity was newly created(`true`) or just loaded from disk. Single argument functions accepting\nonly entities are allowed, but deprecated and will be removed at some point.\n\nIf callback is `null`, then the current entity handler, if present, is removed. Consecutive calls to `entity_load_handler` will add / subtract\nof the currently targeted entity types pool.\n\nLike other global events, calls to `entity_load_handler` should only be attached in apps with global scope. For player scope apps,\nit will be called multiple times, once for each player. That's likely not what you want to do.\n\n```\n// veryfast method of getting rid of all the zombies. Callback is so early, its packets haven't reached yet the clients\n// so to save on log errors, removal of mobs needs to be scheduled for later.\nentity_load_handler('zombie', _(e, new) -> schedule(0, _(outer(e)) -> modify(e, 'remove')))\n\n// another way to do it is to remove the entity when it starts ticking\nentity_load_handler('zombie', _(e, new) -> entity_event(e, 'on_tick', _(e) -> modify(e, 'remove')))\n\n// making all zombies immediately faster and less susceptible to friction of any sort\nentity_load_handler('zombie', _(e, new) -> entity_event(e, 'on_tick', _(e) -> modify(e, 'motion', 1.2*e~'motion')))\n```\n\nWord of caution: entities can be loaded with chunks in various states, for instance when a chunk is being generated, this means\nthat accessing world blocks would cause the game to freeze due to force generating that chunk while generating the chunk. Make\nsure to never assume the chunk is ready and use `entity_load_handler` to schedule actions around the loaded entity,\nor manipulate entity directly.\n\nAlso, it is possible that mobs that spawn with world generation, while being 'added' have their metadata serialized and cached\ninternally (vanilla limitation), so some modifications to these entities may have no effect on them. This affects mobs created with\nworld generation.\n\nFor instance the following handler is safe, as it only accesses the entity directly. It makes all spawned pigmen jump\n```\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, modify(e, 'motion', 0, 1, 0)) )\n```\nBut the following handler, attempting to despawn pigmen that spawn in portals, will cause the game to freeze due to cascading access to blocks that would cause neighbouring chunks\nto force generate, causing also error messages for all pigmen caused by packets send after entity is removed by script.\n```\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new && block(pos(e))=='nether_portal', modify(e, 'remove') ) )\n```\nEasiest method to circumvent these issues is delay the check, which may or may not cause cascade load to happen, but\nwill definitely break the infinite chain.\n```\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, schedule(0, _(outer(e)) -> if(block(pos(e))=='nether_portal', modify(e, 'remove') ) ) ) )\n```\nBut the best is to perform the check first time the entity will be ticked - giving the game all the time to ensure chunk\nis fully loaded and entity processing, removing the tick handler:\n```\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, entity_event(e, 'on_tick', _(e) -> ( if(block(pos(e))=='nether_portal', modify(e, 'remove')); entity_event(e, 'on_tick', null) ) ) ) )\n```\nLooks little convoluted, but that's the safest method to ensure your app won't crash."},"entity_selector":{"signatures":[{"params":[{"name":"selector"}]}],"docs":"Returns entities satisfying given vanilla entity selector. Most complex among all the methods of selecting entities,\nbut the most capable. Selectors are cached so it should be as fast as other methods of selecting entities. Unlike other\nentities fetching / filtering method, this one doesn't guarantee to return entities from current dimension, since\nselectors can return any loaded entity in the world."},"entity_types":{"signatures":[{"params":[{"name":"descriptor"}]}],"docs":"Resolves a given descriptor returning list of entity types that match it. The returned list of types is also a valid list\nof descriptors that can be use elsewhere where entity types are required.\n\nCurrently, the following descriptors are available:\n\n*  `*`: all entities, even `!valid`, matches all entity types.\n*  `valid` - all entities that are not dead (health > 0). All main categories below also return only\nentities in the `valid` category. matches all entity types. `!valid` matches all entites that are already dead of all types.\n*  `living` - all entities that resemble a creature of some sort\n*  `projectile` - all entities or types that are not living that can be throw or projected, `!projectile` matches all types that\n   are not living, but cannot the thrown or projected.\n*  `minecarts` matches all minecart types. `!minecarts` matches all types that are not live, but also not minecarts. Using plural\nsince `minecart` is a proper entity type on its own.\n*  `undead`, `arthropod`, `aquatic`, `regular`, `illager` - all entities / types that belong to any of these groups. All\nliving entities belong to one and only one of these. Corresponding negative (e.g. `!undead`) corresponds to all mobs that are\nliving but don't belong to that group. Entity groups are used in interaction / battle mechanics like smite for undead, or impaling\nfor aquatic. Also certain mechanics interact with groups, like ringing a bell with illagers. All other mobs that don't have any of these traits belong\nto the `regular` group.\n*  `monster`, `creature`, `ambient`, `water_creature`, `water_ambient`, `misc` - another categorization of\nliving entities based on their spawn group. Negative descriptor resolves to all living types that don't belong to that\ncategory.\n* All entity tags including those provided with datapacks. Built-in entity tags include: `skeletons`, `raiders`,\n`beehive_inhabitors` (bee, duh), `arrows` and `impact_projectiles`.\n* Any of the standard entity types, equivalent to selection from `/summon` vanilla command, which is one of the options returned\nby `entity_types()`, except for `'fishing_bobber'` and `'player'`.\n\nAll categories can be preceded with `'!'` which will fetch all entities (unless otherwise noted) that are valid (health > 0) but not\nbelonging to that group."},"flammable":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block is flammable."},"generation_status":{"signatures":[{"params":[{"name":"pos"},{"name":"generation_statuspos"},{"name":"true"}]}],"docs":"Returns generation status as per the ticket system. Can return any value from several available but chunks\ncan only be stable in a few states: `full`, `features`, `liquid_carvers`, and `structure_starts`. Returns `null`\nif the chunk is not in memory unless called with optional `true`."},"hardness":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, indicating hardness of a block."},"harvest":{"signatures":[{"params":[{"name":"player"},{"name":"pos"}]}],"docs":"Causes a block to be harvested by a specified player entity. Honors player item enchantments, as well as damages the\ntool if applicable. If the entity is not a valid player, no block gets destroyed. If a player is not allowed to break\nthat block, a block doesn't get destroyed either."},"in_slime_chunk":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean indicating if the given block position is in a slime chunk."},"inhabited_time":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns inhabited time for a chunk."},"inventory_find":{"signatures":[{"params":[{"name":"inventory"},{"name":"item"},{"name":"start_slot"},{"name":""},{"name":"inventory_findinventory"},{"name":"null"},{"name":"start_slot"}]}],"docs":"Finds the first slot with a corresponding item in the inventory, or if queried with null: the first empty slot.\nReturns slot number if found, or null otherwise. Optional start_slot argument allows to skip all preceeding slots\nallowing for efficient (so not slot-by-slot) inventory search for items.\n\n```scarpet\ninventory_find(player(), 'stone') => 0 // player has stone in first hotbar slot\ninventory_find(player(), null) => null // player's inventory has no empty spot\nwhile( (slot = inventory_find(p, 'diamond', slot)) != null, 41, drop_item(p, slot) )\n    // spits all diamonds from player inventory wherever they are\ninventory_drop(x,y,z, 0) => 64 // removed and spawned in the world a full stack of items\n```\n\nThrows `unknown_item` if item doesn't exist."},"inventory_get":{"signatures":[{"params":[{"name":"inventory"},{"name":"slot"}]}],"docs":"Returns the item in the corresponding inventory slot, or null if slot empty or inventory is invalid. You can use\nnegative numbers to indicate slots counted from 'the back'.\n\n```scarpet\ninventory_get(player(), 0) => null // nothing in first hotbar slot\ninventory_get(x,y,z, 5) => ['stone', 1, {}]\ninventory_get(player(), -1) => ['diamond_pickaxe', 1, {Damage:4}] // slightly damaged diamond pick in the offhand\n```"},"inventory_has_items":{"signatures":[{"params":[{"name":"inventory"}]}],"docs":"Returns true, if the inventory is not empty, false if it is empty, and null, if its not an inventory.\n\n```scarpet    inventory_has_items(player()) => true\n    inventory_has_items(x,y,z) => false // empty chest\n    inventory_has_items(block(pos)) => null // stone\n```"},"inventory_remove":{"signatures":[{"params":[{"name":"inventory"},{"name":"item"},{"name":"amount"}]}],"docs":"Removes amount (defaults to 1) of item from inventory. If the inventory doesn't have the defined amount, nothing\nhappens, otherwise the given amount of items is removed wherever they are in the inventory. Returns boolean\nwhether the removal operation was successful. Easiest way to remove a specific item from player inventory\nwithout specifying the slot.\n\n```scarpet\ninventory_remove(player(), 'diamond') => 1 // removed diamond from player inventory\ninventory_remove(player(), 'diamond', 100) => 0 // player doesn't have 100 diamonds, nothing happened\n```"},"inventory_set":{"signatures":[{"params":[{"name":"inventory"},{"name":"slot"},{"name":"count"},{"name":"item"},{"name":"nbt"}]}],"docs":"Modifies or sets a stack in inventory. specify count 0 to empty the slot. If item is not specified, keeps existing\nitem, just modifies the count. If item is provided - replaces current item. If nbt is provided - adds a tag to the\nstack at slot. Returns previous stack in that slot.\n\n```scarpet\ninventory_set(player(), 0, 0) => ['stone', 64, {}] // player had a stack of stone in first hotbar slot\ninventory_set(player(), 0, 6) => ['diamond', 64, {}] // changed stack of diamonds in player slot to 6\ninventory_set(player(), 0, 1, 'diamond_axe','{Damage:5}') => null //added slightly damaged diamond axe to first player slot\n```"},"inventory_size":{"signatures":[{"params":[{"name":"inventory"}]}],"docs":"Returns the size of the inventory for the entity or block in question. Returns null if the block or entity don't\nhave an inventory.\n\n```scarpet\ninventory_size(player()) => 41\ninventory_size('enderchest', player()) => 27 // enderchest\ninventory_size('equipment', player()) => 6 // equipment\ninventory_size(null, player()) => 41  // default inventory for players\n\ninventory_size(x,y,z) => 27 // chest\ninventory_size(block(pos)) => 5 // hopper\n\nhorse = spawn('horse', x, y, z);\ninventory_size(horse); => 2 // default horse inventory\ninventory_size('equipment', horse); => 6 // unused horse equipment inventory\ninventory_size(null, horse); => 2 // default horse\n\ncreeper = spawn('creeper', x, y, z);\ninventory_size(creeper); => 6 // default creeper inventory is equipment since it has no other\ninventory_size('equipment', creeper); => 6 // unused horse equipment inventory\ninventory_size(null, creeper); => 6 // creeper default is its equipment\n```"},"is_chunk_generated":{"signatures":[{"params":[{"name":"pos"}]}],"docs":", `is_chunk_generated(pos, force)`\n\nReturns `true` if the region file for the chunk exists,\n`false` otherwise. If optional force is `true` it will also check if the chunk has a non-empty entry in its region file\nCan be used to assess if the chunk has been touched by the game or not.\n\n`generation_status(pos, false)` only works on currently loaded chunks, and `generation_status(pos, true)` will create\nan empty loaded chunk, even if it is not needed, so `is_chunk_generated` can be used as a efficient proxy to determine\nif the chunk physically exists.\n\nRunning `is_chunk_generated` is has no effects on the world, but since it is an external file operation, it is\nconsiderably more expensive (unless area is loaded) than other generation and loaded checks."},"item_list":{"signatures":[{"params":[{"name":"tag"}]}],"docs":"With no arguments, returns a list of all items in the game. With an item tag provided, list items matching the tag, or `null` if tag is not valid."},"item_tags":{"signatures":[{"params":[{"name":"item"},{"name":"tag"}]}],"docs":"Returns list of tags the item belongs to, or, if tag is provided, `true` if an item matches the tag, `false` if it doesn't and `null` if that's not a valid tag\n\nThrows `unknown_item` if item doesn't exist."},"light":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning the total light level at position."},"liquid":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block is liquid, or waterlogged (with any liquid)."},"loaded":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block is accessible for the game mechanics. Normally `scarpet` doesn't check if operates\non loaded area - the game will automatically load missing blocks. We see this as an advantage. Vanilla `fill/clone`\ncommands only check the specified corners for loadness.\n\nTo check if a block is truly loaded, I mean in memory, use `generation_status(x) != null`, as chunks can still be loaded\noutside of the playable area, just are not used by any of the game mechanic processes.\n\n```scarpet\nloaded(pos(player()))  => 1\nloaded(100000,100,1000000)  => 0\n```"},"loaded_ep":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block is loaded and entity processing, as per 1.13.2\n\nDeprecated as of scarpet 1.6, use `loaded_status(x) > 0`, or just `loaded(x)` with the same effect"},"loaded_status":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns loaded status as per new 1.14 chunk ticket system, 0 for inaccessible, 1 for border chunk, 2 for redstone ticking,\n3 for entity ticking"},"map_colour":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns the map colour of a block at position. One of:\n\n`'air'`, `'grass'`, `'sand'`, `'wool'`, `'tnt'`, `'ice'`, `'iron'`, `'foliage'`, `'snow'`, `'clay'`, `'dirt'`,\n`'stone'`, `'water'`, `'wood'`, `'quartz'`, `'adobe'`, `'magenta'`, `'light_blue'`, `'yellow'`, `'lime'`, `'pink'`,\n`'gray'`, `'light_gray'`, `'cyan'`, `'purple'`, `'blue'`, `'brown'`, `'green'`, `'red'`, `'black'`, `'gold'`,\n`'diamond'`, `'lapis'`, `'emerald'`, `'obsidian'`, `'netherrack'`, `'white_terracotta'`, `'orange_terracotta'`,\n`'magenta_terracotta'`, `'light_blue_terracotta'`, `'yellow_terracotta'`, `'lime_terracotta'`, `'pink_terracotta'`,\n`'gray_terracotta'`, `'light_gray_terracotta'`, `'cyan_terracotta'`, `'purple_terracotta'`, `'blue_terracotta'`,\n`'brown_terracotta'`, `'green_terracotta'`, `'red_terracotta'`, `'black_terracotta'`,\n`'crimson_nylium'`, `'crimson_stem'`, `'crimson_hyphae'`, `'warped_nylium'`, `'warped_stem'`, `'warped_hyphae'`, `'warped_wart'`"},"material":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns `'unknown'`. The concept of material for blocks is removed. On previous versions it returned the name of the material the block\nwas made of."},"neighbours":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns the list of 6 neighbouring blocks to the argument. Commonly used with other loop functions like `for`.\n\n```scarpet\nfor(neighbours(x,y,z),air(_)) => 4 // number of air blocks around a block\n```"},"opacity":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning the opacity level of a block."},"place_item":{"signatures":[{"params":[{"name":"item"},{"name":"pos"},{"name":"facing"},{"name":"sneak"}]}],"docs":"Uses a given item in the world like it was used by a player. Item names are default minecraft item name,\nless the minecraft prefix. Default facing is 'up', but there are other options: 'down', 'north', 'east', 'south',\n'west', but also there are other secondary directions important for placement of blocks like stairs, doors, etc.\nTry experiment with options like 'north-up' which is placed facing north with cursor pointing to the upper part of the\nblock, or 'up-north', which means a block placed facing up (player looking down) and placed smidge away of the block\ncenter towards north. Optional sneak is a boolean indicating if a player would be sneaking while placing the\nblock - this option only affects placement of chests and scaffolding at the moment.\n\nWorks with items that have the right-click effect on the block placed, like `bone_meal` on grass or axes on logs,\nbut doesn't open chests / containers, so have no effect on interactive blocks, like TNT, comparators, etc.\n\nReturns true if placement/use was\nsuccessful, false otherwise.\n\nThrows `unknown_item` if `item` doesn't exist\n\n```scarpet\nplace_item('stone',x,y,z) // places a stone block on x,y,z block\nplace_item('piston,x,y,z,'down') // places a piston facing down\nplace_item('carrot',x,y,z) // attempts to plant a carrot plant. Returns true if could place carrots at that position.\nplace_item('bone_meal',x,y,z) // attempts to bonemeal the ground.\nplace_item('wooden_axe',x,y,z) // attempts to strip the log.\n```"},"player":{"signatures":[{"params":[{"name":""},{"name":"playertype"},{"name":"playername"}]}],"docs":"With no arguments, it returns the calling player or the player closest to the caller.\nFor player-scoped apps (which is a default) its always the owning player or `null` if it not present even if some code\nstill runs in their name.\nNote that the main context\nwill receive `p` variable pointing to this player. With `type` or `name` specified, it will try first to match a type,\nreturning a list of players matching a type, and if this fails, will assume its player name query retuning player with\nthat name, or `null` if no player was found. With `'all'`, list of all players in the game, in all dimensions, so end\nuser needs to be cautious, that you might be referring to wrong blocks and entities around the player in question.\nWith `type = '*'` it returns all players in caller dimension, `'survival'` returns all survival and adventure players,\n`'creative'` returns all creative players, `'spectating'` returns all spectating players, and `'!spectating'`,\nall not-spectating players. If all fails, with `name`, the player in question, if he/she is logged in."},"plop":{"signatures":[{"params":[{"name":"pos"},{"name":"what"}]}],"docs":"Plops a structure or a feature at a given `pos`, so block, triple position coordinates or a list of coordinates.\nTo `what` gets plopped and exactly where it often depends on the feature or structure itself.\n\nRequires a `Structure Type`,  `Structure`, `World Generation Feature` or `Custom Scarpet Feature` name (see\nabove). If standard name is used, the variant of the structure may depend on the biome, otherwise the default\nstructure for this type will be generated.\n\nAll structures are chunk aligned, and often span multiple chunks. Repeated calls to plop a structure in the same chunk\nwould result either in the same structure generated on top of each other, or with different state, but same position.\nMost structures generate at specific altitudes, which are hardcoded, or with certain blocks around them. API will\ncancel all extra position / biome / random requirements for structure / feature placement, but some hardcoded\nlimitations may still cause some of structures/features not to place. Some features require special blocks to be\npresent, like coral -> water or ice spikes -> snow block, and for some features, like fossils, placement is all sorts\nof messed up. This can be partially avoided for structures by setting their structure information via `set_structure`,\nwhich sets it without looking into world blocks, and then use `plop` to fill it with blocks. This may, or may not work.\n\nAll generated structures will retain their properties, like mob spawning, however in many cases the world / dimension\nitself has certain rules to spawn mobs, like plopping a nether fortress in the overworld will not spawn nether mobs,\nbecause nether mobs can spawn only in the nether, but plopped in the nether - will behave like a valid nether fortress.\n# Iterating over larger areas of blocks\n\nThese functions help scan larger areas of blocks without using generic loop functions, like nested `loop`."},"poi":{"signatures":[{"params":[{"name":"pos"},{"name":"poipos"},{"name":"radius"},{"name":"type"},{"name":"status"},{"name":"column_search"}]}],"docs":"Queries a POI (Point of Interest) at a given position, returning `null` if none is found, or tuple of poi type and its\noccupancy load. With optional `type`, `radius` and `status`, returns a list of POIs around `pos` within a\ngiven `radius`. If the `type` is specified, returns only poi types of that types, or everything if omitted or `'any'`.\nIf `status` is specified (either `'any'`, `'available'`, or `'occupied'`) returns only POIs with that status.\nWith `column_search` set to `true`, it will return all POIs in a cuboid with `radius` blocks away on x and z, in the entire\nblock column from 0 to 255. Default (`false`) returns POIs within a spherical area centered on `pos` and with `radius`\nradius.\n\nAll results of `poi` calls are returned in sorted order with respect to the euclidean distance to the requested center of `pos`.\n\nThe return format of the results is a list of poi type, occupancy load, and extra triple of coordinates.\n\nQuerying for POIs using the radius is the intended use of POI mechanics, and the ability of accessing individual POIs\nvia `poi(pos)` in only provided for completeness.\n\n```scarpet\npoi(x,y,z) => null  // nothing set at position\npoi(x,y,z) => ['meeting',3]  // its a bell-type meeting point occupied by 3 villagers\npoi(x,y,z,5) => []  // nothing around\npoi(x,y,z,5) => [['nether_portal',0,[7,8,9]],['nether_portal',0,[7,9,9]]] // two portal blocks in the range\n```"},"pos":{"signatures":[{"params":[{"name":"block"},{"name":"posentity"}]}],"docs":"Returns a triple of coordinates of a specified block or entity. Technically entities are queried with `query` function\nand the same can be achieved with `query(entity,'pos')`, but for simplicity `pos` allows to pass all positional objects.\n\n```scarpet\npos(block(0,5,0)) => [0,5,0]\npos(player()) => [12.3, 45.6, 32.05]\npos(block('stone')) => Error: Cannot fetch position of an unrealized block\n```"},"pos_offset":{"signatures":[{"params":[{"name":"pos"},{"name":"direction"},{"name":"amount"}]}],"docs":"Returns a coords triple that is offset in a specified `direction` by `amount` of blocks. The default offset amount is\n1 block. To offset into opposite facing, use negative numbers for the `amount`.\n\n```scarpet\npos_offset(block(0,5,0), 'up', 2)  => [0,7,0]\npos_offset([0,5,0], 'up', -2 ) => [0,3,0]\n```"},"power":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning redstone power level at position."},"property":{"signatures":[{"params":[{"name":"pos"},{"name":"name"}]}],"docs":"Deprecated by `block_state(pos, name)`"},"random_tick":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Causes a random tick at position."},"recipe_data":{"signatures":[{"params":[{"name":"item"},{"name":"type"}]}],"docs":", `recipe_data(recipe, type?)`\n\nreturns all recipes matching either an `item`, or represent actual `recipe` name. In vanilla datapack, for all items\nthat have one recipe available, the recipe name is the same as the item name but if an item has multiple recipes, its\ndirect name can be different.\n\nRecipe type can take one of the following options:\n * `'crafting'` - default, crafting table recipe\n * `'smelting'` - furnace recipe\n * `'blasting'` - blast furnace recipe\n * `'smoking'` - smoker recipe\n * `'campfire_cooking'` - campfire recipe\n * `'stonecutting'` - stonecutter recipe\n * `'smithing'` - smithing table (1.16+)\n\n The return value is a list of available recipes (even if there is only one recipe available). Each recipe contains of\n an item triple of the crafting result, list of ingredients, each containing a list of possible variants of the\n ingredients in this slot, as item triples, or `null` if its a shaped recipe and a given slot in the patterns is left\n empty, and recipe specification as another list. Possible recipe specs is:\n  * `['shaped', width, height]` - shaped crafting. `width` and `height` can be 1, 2 or 3.\n  * `['shapeless']` - shapeless crafting\n  * `['smelting', duration, xp]` - smelting/cooking recipes\n  * `['cutting']` - stonecutter recipe\n  * `['special']` - special crafting recipe, typically not present in the crafting menu\n  * `['custom']` - other recipe types\n\nNote that ingredients are specified as tripes, with count and nbt information. Currently all recipes require always one\nof the ingredients, and for some recipes, even if the nbt data for the ingredient is specified (e.g. `dispenser`), it\ncan accept items of any tags.\n\nAlso note that some recipes leave some products in the crafting window, and these can be determined using\n `crafting_remaining_item()` function\n\n Examples:\n ```scarpet\n recipe_data('iron_ingot_from_nuggets')\n recipe_data('iron_ingot')\n recipe_data('glass', 'smelting')\n ```"},"rect":{"signatures":[{"params":[{"name":"center"},{"name":"range"},{"name":"upper_range"}]}],"docs":"Returns an iterator, just like `range` function that iterates over a rectangular area of blocks. If only center\npoint is specified, it iterates over 27 blocks (range of 1). If `range` arguments are specified, expands selection by\nthe respective number of blocks in each direction. If `upper_range` arguments are specified, it uses `range` for\nnegative offset, and `upper_range` for positive, similar to `scan`.\n\nBasically the arguments are the same as the first three arguments of `scan`, except this function returns the list of\nblocks that `scan` would evaluate over. If you are going to iterate over these blocks, like `for(rect(args), do_something())`,\nthen `scan(args, do_something())` is an equivalent, yet more compute-friendly alternative, especially for very large areas.\n\n`center` can be defined either as three coordinates, a list of three coords, or a block value.\n`range` and `upper_range` can have the same representations, just if they are block values, it computes the distance to the center\nas range instead of taking the values as is.`"},"reload_chunk":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Sends full chunk data to clients. Useful when lots stuff happened and you want to refresh it on the clients."},"reset_chunk":{"signatures":[{"params":[{"name":"pos"}]}],"docs":", `reset_chunk(from_pos, to_pos)`, `reset_chunk([pos, ...])`\nRemoves and resets the chunk, all chunks in the specified area or all chunks in a list at once, removing all previous\nblocks and entities, and replacing it with a new generation. For all currently loaded chunks, they will be brought\nto their current generation status, and updated to the player. All chunks that are not in the loaded area, will only\nbe generated to the `'structure_starts'` status, allowing to generate them fully as players are visiting them.\nChunks in the area that has not been touched yet by the game will not be generated / regenerated.\n\nIt returns a `map` with a report indicating how many chunks were affected, and how long each step took:\n * `requested_chunks`: total number of chunks in the requested area or list\n * `affected_chunks`: number of chunks that will be removed / regenerated\n * `loaded_chunks`: number of currently loaded chunks in the requested area / list\n * `relight_count`: number of relit chunks\n * `relight_time`: time took to relit chunks\n * `layer_count_<status>`: number of chunks for which a `<status>` generation step has been performed\n * `layer_time_<status>`: cumulative time for all chunks spent on generating `<status>` step"},"sample_noise":{"signatures":[{"params":[{"name":""}]}],"docs":", `sample_noise(pos, ... types?)` 1.18+\n\nSamples the world generation noise values / data driven density function(s) at a given position.\n\nIf no types are passed in, or no arguments are given, it returns a list of all the available registry defined density functions.\n\nWith a single function name passed in, it returns a scalar. With multiple function names passed in, it returns a list of results.\n\nFunction accepts any registry defined density functions, both built in, as well as namespaced defined in datapacks.\nOn top of that, scarpet provides the following list of noises sampled directly from the current level (and not returned with no-argument call):\n\n\n`'barrier_noise'`, `'fluid_level_floodedness_noise'`, `'fluid_level_spread_noise'`, `'lava_noise'`,\n`'temperature'`, `'vegetation'`, `'continents'`, `'erosion'`, `'depth'`, `'ridges'`,\n`'initial_density_without_jaggedness'`, `'final_density'`, `'vein_toggle'`, `'vein_ridged'` and `'vein_gap'`\n\n```scarpet\n// requesting single value\nsample_density(pos, 'continents') => 0.211626790923\n// passing type as multiple arguments\nsample_density(pos, 'continents', 'depth', 'overworld/caves/pillars', 'mydatapack:foo/my_function') => [-0.205013844481, 1.04772473438, 0.211626790923, 0.123]\n```"},"scan":{"signatures":[{"params":[{"name":"center"},{"name":"range"},{"name":"upper_range"},{"name":"expr"}]}],"docs":"Evaluates expression over area of blocks defined by its center `center = (cx, cy, cz)`, expanded in all directions\nby `range = (dx, dy, dz)` blocks, or optionally in negative with `range` coords, and `upper_range` coords in\npositive values. That means that if you want a box starting at the northwest coord with given base, width and height\ndimensions, you can do `'scan(center, 0, 0, 0, w, h, d, ...)`.\n\n`center` can be defined either as three coordinates, a single tuple of three coords, or a block value.\n`range` and `upper_range` can have the same representations, just if they are block values, it computes the distance to\nthe center as range instead of taking the values as is. That way you can iterate from the center to a box whose surface\narea constains the `range` and/or `upper_range` blocks.\n\n`expr` receives `_x, _y, _z` variables as coords of current analyzed block and `_`, which represents the block itself.\n\nReturns number of successful evaluations of `expr` (with `true` boolean result) unless called in void context,\nwhich would cause the expression not be evaluated for their boolean value.\n\n`scan` also handles `continue` and `break` statements, using `continue`'s return value to use in place of expression\nreturn value. `break` return value has no effect."},"see_sky":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, returning true if the block can see sky."},"set":{"signatures":[{"params":[{"name":"pos"},{"name":"block"},{"name":"property"},{"name":"value"},{"name":""},{"name":"block_data"}]}],"docs":", `set(pos, block, [property?, value?, ...], block_data?)`, `set(pos, block, {property? -> value?, ...}, block_data?)`\n\nFirst argument for the `set` function is either a coord triple, list of three numbers, or a world localized block value.\nSecond argument, `block`, is either an existing block value, a result of `block()` function, or a string value indicating the block name\nwith optional state and block data. It is then followed by an optional\n`property - value` pairs for extra block state (which can also be provided in a list or a map). Optional `block_data` include the block data to\nbe set for the target block.\n\nIf `block` is specified only by name, then if a\ndestination block is the same the `set` operation is skipped, otherwise is executed, for other potential extra\nproperties that the original source block may have contained.\n\nThe returned value is either the block state that has been set, or `false` if block setting was skipped, or failed\n\nThrows `unknown_block` if provided block to set is not valid\n\n```scarpet\nset(0,5,0,'bedrock')  => bedrock\nset([0,5,0], 'bedrock')  => bedrock\nset(block(0,5,0), 'bedrock')  => bedrock\nscan(0,5,0,0,0,0,set(_,'bedrock'))  => 1\nset(pos(player()), 'bedrock')  => bedrock\nset(0,0,0,'bedrock')  => 0   // or 1 in overworlds generated in 1.8 and before\nscan(0,100,0,20,20,20,set(_,'glass'))\n    // filling the area with glass\nscan(0,100,0,20,20,20,set(_,block('glass')))\n    // little bit faster due to internal caching of block state selectors\nb = block('glass'); scan(0,100,0,20,20,20,set(_,b))\n    // yet another option, skips all parsing\nset(x,y,z,'iron_trapdoor')  // sets bottom iron trapdoor\n\nset(x,y,z,'iron_trapdoor[half=top]')  // sets the top trapdoor\nset(x,y,z,'iron_trapdoor','half','top') // also correct - top trapdoor\nset(x,y,z,'iron_trapdoor', ['half','top']) // same\nset(x,y,z,'iron_trapdoor', {'half' -> 'top'}) // same\nset(x,y,z, block('iron_trapdoor[half=top]')) // also correct, block() provides extra parsing of block state\n\nset(x,y,z,'hopper[facing=north]{Items:[{Slot:1b,id:\"minecraft:slime_ball\",Count:16b}]}') // extra block data\nset(x,y,z,'hopper', {'facing' -> 'north'}, nbt('{Items:[{Slot:1b,id:\"minecraft:slime_ball\",Count:16b}]}') ) // same\n```"},"set_biome":{"signatures":[{"params":[{"name":"pos"},{"name":"biome_name"},{"name":"updatetrue"}]}],"docs":"Changes the biome at that block position. if update is specified and false, then chunk will not be refreshed\non the clients. Biome changes can only be sent to clients with the entire data from the chunk.\n\nBe aware that depending on the MC version and dimension settings biome can be set either in a 1x1x256\ncolumn or 4x4x4 hyperblock, so for some versions Y will be ignored and for some precision of biome\nsetting is less than 1x1x1 block.\n\nThrows `unknown_biome` if the `biome_name` doesn't exist."},"set_poi":{"signatures":[{"params":[{"name":"pos"},{"name":"type"},{"name":"occupancy"}]}],"docs":"Sets a Point of Interest (POI) of a specified type with optional custom occupancy. By default new POIs are not occupied.\nIf type is `null`, POI at position is removed. In any case, previous POI is also removed. Available POI types are:\n\n*   `'unemployed', 'armorer', 'butcher', 'cartographer', 'cleric', 'farmer', 'fisherman', 'fletcher', 'leatherworker', 'librarian', 'mason', 'nitwit', 'shepherd', 'toolsmith', 'weaponsmith', 'home', 'meeting', 'beehive', 'bee_nest', 'nether_portal'`\n\nInterestingly, `unemployed`, and `nitwit` are not used in the game, meaning, they could be used as permanent spatial\nmarkers for scarpet apps. `meeting` is the only one with increased max occupancy of 32.\n\nThrows `unknown_poi` if the provided point of interest doesn't exist"},"set_structure":{"signatures":[{"params":[{"name":"pos"},{"name":"structure_name"},{"name":"set_structurepos"},{"name":"structure_name"},{"name":"null"}]}],"docs":"Creates or removes structure information of a structure associated with a chunk of `pos`. Unlike `plop`, blocks are\nnot placed in the world, only structure information is set. For the game this is a fully functional structure even\nif blocks are not set. To remove the structure a given point is in, use `structure_references` to find where current\nstructure starts.\n\nRequires a `Structure Variant` or `Standard Structure` name (see above). If standard name is used, the variant of the\nstructure may depend on the biome, otherwise the default structure for this type will be generated.\n\nThrows `unknown_structure` if structure doesn't exist."},"sky_light":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Numeric function, returning the sky light at position (from sky access)."},"solid":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block is solid."},"spawn":{"signatures":[{"params":[{"name":"name"},{"name":"pos"},{"name":"nbt"}]}],"docs":"Spawns and places an entity in world, like `/summon` vanilla command. Requires a position to spawn, and optional\nextra nbt data to merge with the entity. What makes it different from calling `run('summon ...')`, is the fact that\nyou get the entity back as a return value, which is swell."},"spawn_potential":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Returns spawn potential at a location (1.16+ only)"},"stack_limit":{"signatures":[{"params":[{"name":"item"}]}],"docs":"Returns number indicating what is the stack limit for the item. Its typically 1 (non-stackable), 16 (like buckets),\nor 64 - rest. It is recommended to consult this, as other inventory API functions ignore normal stack limits, and\nit is up to the programmer to keep it at bay. As of 1.13, game checks for negative numbers and setting an item to\nnegative is the same as empty.\n\nThrows `unknown_item` if item doesn't exist.\n\n```scarpet\nstack_limit('wooden_axe') => 1\nstack_limit('ender_pearl') => 16\nstack_limit('stone') => 64\n```"},"structure_eligibility":{"signatures":[{"params":[{"name":"pos"},{"name":"structure"},{"name":"size_needed"}]}],"docs":"Checks worldgen eligibility for a structure in a given chunk. Requires a `Structure Variant` name (see above),\nor `Standard Structure` to check structures of this type.\nIf no structure is given, or `null`, then it will check\nfor all structures. If bounding box of the structures is also requested, it will compute size of potential\nstructures. This function, unlike other in the `structure*` category is not using world data nor accesses chunks\nmaking it preferred for scoping ungenerated terrain, but it takes some compute resources to calculate the structure.\n\nUnlike `'structure'` this will return a tentative structure location. Random factors in world generation may prevent\nthe actual structure from forming.\n\nIf structure is specified, it will return `null` if a chunk is not eligible or invalid, `true` if the structure should appear, or\na map with two values: `'box'` for a pair of coordinates indicating bounding box of the structure, and `'pieces'` for\nlist of elements of the structure (as a tuple), with its name, direction, and box coordinates of the piece.\n\nIf structure is not specified, or a `Standard Structure` was specified, like `'village'`,it will return a set of structure names that are eligible, or a map with structures\nas keys, and same type of map values as with a single structure call. An empty set or an empty map would indicate that nothing\nshould be generated there.\n\nThrows `unknown_structure` if structure doesn't exist."},"structure_references":{"signatures":[{"params":[{"name":"pos"},{"name":"structure_referencespos"},{"name":"structure_name"}]}],"docs":"Returns structure information that a chunk with a given block position is part of. `structure_references` function\ncan be called with a block, or a block and a structure name. In the first case it returns a list of structure names\nthat give chunk belongs to. When called with an extra structure name, returns list of positions pointing to the\nlowest block position in chunks that hold structure starts for these structures. You can query that chunk structures\nthen to get its bounding boxes.\n\nRequires a `Standard Structure` name (see above)."},"structures":{"signatures":[{"params":[{"name":"pos"},{"name":"structurespos"},{"name":"structure_name"}]}],"docs":"Returns structure information for a given block position. Note that structure information is the same for all the\nblocks from the same chunk. `structures` function can be called with a block, or a block and a structure name. In\nthe first case it returns a map of structures at a given position, keyed by structure name, with values indicating\nthe bounding box of the structure - a pair of two 3-value coords (see examples). When called with an extra structure\nname, returns a map with two values, `'box'` for bounding box of the structure, and `'pieces'` for a list of\ncomponents for that structure, with their name, direction and two sets of coordinates\nindicating the bounding box of the structure piece. If structure is invalid, its data will be `null`.\n\nRequires a `Standard Structure` name (see above)."},"suffocates":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block causes suffocation."},"ticks_randomly":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block ticks randomly."},"top":{"signatures":[{"params":[{"name":"type"},{"name":"pos"}]}],"docs":"Returns the Y value of the topmost block at given x, z coords (y value of a block is not important), according to the\nheightmap specified by `type`. Valid options are:\n\n*   `light`: topmost light blocking block (1.13 only)\n*   `motion`: topmost motion blocking block\n*   `terrain`: topmost motion blocking block except leaves\n*   `ocean_floor`: topmost non-water block\n*   `surface`: topmost surface block\n\n```scarpet\ntop('motion', x, y, z)  => 63\ntop('ocean_floor', x, y, z)  => 41\n```"},"transparent":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Boolean function, true if the block is transparent."},"update":{"signatures":[{"params":[{"name":"pos"}]}],"docs":"Causes a block update at position."},"volume":{"signatures":[{"params":[{"name":"from_pos"},{"name":"to_pos"},{"name":"expr"}]}],"docs":"Evaluates expression for each block in the area, the same as the `scan` function, but using two opposite corners of\nthe rectangular cuboid. Any corners can be specified, its like you would do with `/fill` command.\nYou can use a position or three coordinates to specify, it doesn't matter.\n\nFor return value and handling `break` and `continue` statements, see `scan` function above."},"weather":{"signatures":[{"params":[{"name":""}]}],"docs":",`weather(type)`,`weather(type, ticks)`\n\nIf called with no args, returns `'clear'`, `'rain` or `'thunder'` based on the current weather. If thundering, will\nalways return `'thunder'`, if not will return `'rain'` or `'clear'` based on the current weather.\n\nWith one arg, (either `'clear'`, `'rain` or `'thunder'`), returns the number of remaining ticks for that weather type.\nNB: It can thunder without there being a thunderstorm; there has to be both rain and thunder to form a storm. So if\nrunning `weather()` returns `'thunder'`, you can use `weather('rain')>0` to see if there's a storm going on.\n\nWith two args, sets the weather to the given `type` for `ticks` ticks.\n\n## Block and World querying"},"without_updates":{"signatures":[{"params":[{"name":"expr"}]}],"docs":"Evaluates subexpression without causing updates when blocks change in the world.\n\nFor synchronization sake, as well as from the fact that suppressed update can only happen within a tick,\nthe call to the `expr` is docked on the main server task.\n\nConsider following scenario: We would like to generate a bunch of terrain in a flat world following a perlin noise\ngenerator. The following code causes a cascading effect as blocks placed on chunk borders will cause other chunks to get\nloaded to full, thus generated:\n\n```scarpet\n__config() -> {'scope' -> 'global'};\n__on_chunk_generated(x, z) -> (\n  scan(x,0,z,0,0,0,15,15,15,\n    if (perlin(_x/16, _y/8, _z/16) > _y/16,\n      set(_, 'black_stained_glass');\n    )\n  )\n)\n```\n\nThe following addition resolves this issue, by not allowing block updates past chunk borders:\n\n```scarpet\n__config() -> {'scope' -> 'global'};\n__on_chunk_generated(x, z) -> (\n  without_updates(\n    scan(x,0,z,0,0,0,15,15,15,\n      if (perlin(_x/16, _y/8, _z/16) > _y/16,\n        set(_, 'black_stained_glass');\n      )\n    )\n  )\n)\n```"}}
