### `join(delim, list), join(delim, values ...)`

Returns a string that contains joined elements of the list, iterator, or all values,
concatenated with `delim` delimiter

```scarpet
join('-',range(10))  => 0-1-2-3-4-5-6-7-8-9
join('-','foo')  => foo
join('-', 'foo', 'bar')  => foo-bar
```

### `split(delim?, expr)`

Splits a string under `expr` by `delim` which can be a regular expression. If no delimiter is specified, it splits
by characters.

If `expr` is a list, it will split the list into multiple sublists by the element (s) which equal `delim`, or which equal the empty string
in case no delimiter is specified.

Splitting a `null` value will return an empty list.

```scarpet
split('foo') => [f, o, o]
split('','foo')  => [f, o, o]
split('.','foo.bar')  => []
split('\\.','foo.bar')  => [foo, bar]
split(1,[2,5,1,2,3,1,5,6]) => [[2,5],[2,3],[5,6]]
split(1,[1,2,3,1,4,5,1] => [[], [2,3], [4,5], []]
split(null) => []
```

### `slice(expr, from, to?)`

extracts a substring, or sublist (based on the type of the result of the expression under expr with
starting index of `from`, and ending at `to` if provided, or the end, if omitted. Can use negative indices to
indicate counting form the back of the list, so `-1 <=> length(_)`.

Special case is made for iterators (`range`, `rect` etc), which does require non-negative indices (negative `from` is treated as
`0`, and negative `to` as `inf`), but allows retrieving parts of the sequence and ignore
other parts. In that case consecutive calls to `slice` will refer to index `0` the current iteration position since iterators
cannot go back nor track where they are in the sequence (see examples).

```scarpet
slice([0,1,2,3,4,5], 1, 3)  => [1, 2]
slice('foobar', 0, 1)  => 'f'
slice('foobar', 3)  => 'bar'
slice(range(10), 3, 5)  => [3, 4]
slice(range(10), 5)  => [5, 6, 7, 8, 9]
r = range(100); [slice(r, 5, 7), slice(r, 1, 3)]  => [[5, 6], [8, 9]]
```

### `sort(list), sort(values ...)`

Sorts in the default sortographical order either all arguments, or a list if its the only argument.
It returns a new sorted list, not affecting the list passed to the argument

```scarpetsort(3,2,1)  => [1, 2, 3]
sort('a',3,11,1)  => [1, 3, 11, 'a']
list = [4,3,2,1]; sort(list)  => [1, 2, 3, 4]
```

### `sort_key(list, key_expr)`

Sorts a copy of the list in the order or keys as defined by the `key_expr` for each element

```scarpet
sort_key([1,3,2],_)  => [1, 2, 3]
sort_key([1,3,2],-_)  => [3, 2, 1]
sort_key([range(10)],rand(1))  => [1, 0, 9, 6, 8, 2, 4, 5, 7, 3]
sort_key([range(20)],str(_))  => [0, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 4, 5, 6, 7, 8, 9]
```

### `range(to), range(from, to), range(from, to, step)`

Creates a range of numbers from `from`, no greater/larger than `to`. The `step` parameter dictates not only the
increment size, but also direction (can be negative). The returned value is not a proper list, just the iterator
but if for whatever reason you need a proper list with all items evaluated, use `[range(to)]`.
Primarily to be used in higher order functions

```scarpet
range(10)  => [...]
[range(10)]  => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
map(range(10),_*_)  => [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
reduce(range(10),_a+_, 0)  => 45
range(5,10)  => [5, 6, 7, 8, 9]
range(20, 10, -2)  => [20, 18, 16, 14, 12]
range(-0.3, 0.3, 0.1)  => [-0.3, -0.2, -0.1, 0, 0.1, 0.2]
range(0.3, -0.3, -0.1) => [0.3, 0.2, 0.1, -0, -0.1, -0.2]
```
