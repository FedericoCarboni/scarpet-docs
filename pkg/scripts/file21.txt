### `block(x, y, z)`, `block([x,y,z])`, `block(state)`

Returns either a block from specified location, or block with a specific state (as used by `/setblock` command),
so allowing for block properties, block entity data etc. Blocks otherwise can be referenced everywhere by its simple
string name, but its only used in its default state.

```scarpet
block('air')  => air
block('iron_trapdoor[half=top]')  => iron_trapdoor
block(0,0,0) == block('bedrock')  => 1
block('hopper[facing=north]{Items:[{Slot:1b,id:"minecraft:slime_ball",Count:16b}]}') => hopper
```

Retrieving a block with `block` function has also a side-effect of evaluating its current state and data.
So if you use it later it will reflect block state and data of the block that was when block was called, rather than
when it was used. Block values passed in various places like `scan` functions, etc, are not fully evaluated unless
its properties are needed. This means that if the block at the location changes before its queried in the program this
might result in getting the later state, which might not be desired. Consider the following example:

Throws `unknown_block` if provided input is not valid.

```scarpetset(10,10,10,'stone');
scan(10,10,10,0,0,0, b = _);
set(10,10,10,'air');
print(b); // 'air', block was remembered 'lazily', and evaluated by `print`, when it was already set to air
set(10,10,10,'stone');
scan(10,10,10,0,0,0, b = block(_));
set(10,10,10,'air');
print(b); // 'stone', block was evaluated 'eagerly' but call to `block`
```

### `set(pos, block, property?, value?, ..., block_data?)`, `set(pos, block, [property?, value?, ...], block_data?)`, `set(pos, block, {property? -> value?, ...}, block_data?)`

First argument for the `set` function is either a coord triple, list of three numbers, or a world localized block value.
Second argument, `block`, is either an existing block value, a result of `block()` function, or a string value indicating the block name
with optional state and block data. It is then followed by an optional
`property - value` pairs for extra block state (which can also be provided in a list or a map). Optional `block_data` include the block data to
be set for the target block.

If `block` is specified only by name, then if a
destination block is the same the `set` operation is skipped, otherwise is executed, for other potential extra
properties that the original source block may have contained.

The returned value is either the block state that has been set, or `false` if block setting was skipped, or failed

Throws `unknown_block` if provided block to set is not valid

```scarpet
set(0,5,0,'bedrock')  => bedrock
set([0,5,0], 'bedrock')  => bedrock
set(block(0,5,0), 'bedrock')  => bedrock
scan(0,5,0,0,0,0,set(_,'bedrock'))  => 1
set(pos(player()), 'bedrock')  => bedrock
set(0,0,0,'bedrock')  => 0   // or 1 in overworlds generated in 1.8 and before
scan(0,100,0,20,20,20,set(_,'glass'))
    // filling the area with glass
scan(0,100,0,20,20,20,set(_,block('glass')))
    // little bit faster due to internal caching of block state selectors
b = block('glass'); scan(0,100,0,20,20,20,set(_,b))
    // yet another option, skips all parsing
set(x,y,z,'iron_trapdoor')  // sets bottom iron trapdoor

set(x,y,z,'iron_trapdoor[half=top]')  // sets the top trapdoor
set(x,y,z,'iron_trapdoor','half','top') // also correct - top trapdoor
set(x,y,z,'iron_trapdoor', ['half','top']) // same
set(x,y,z,'iron_trapdoor', {'half' -> 'top'}) // same
set(x,y,z, block('iron_trapdoor[half=top]')) // also correct, block() provides extra parsing of block state

set(x,y,z,'hopper[facing=north]{Items:[{Slot:1b,id:"minecraft:slime_ball",Count:16b}]}') // extra block data
set(x,y,z,'hopper', {'facing' -> 'north'}, nbt('{Items:[{Slot:1b,id:"minecraft:slime_ball",Count:16b}]}') ) // same
```

### `without_updates(expr)`

Evaluates subexpression without causing updates when blocks change in the world.

For synchronization sake, as well as from the fact that suppressed update can only happen within a tick,
the call to the `expr` is docked on the main server task.

Consider following scenario: We would like to generate a bunch of terrain in a flat world following a perlin noise
generator. The following code causes a cascading effect as blocks placed on chunk borders will cause other chunks to get
loaded to full, thus generated:

```scarpet
__config() -> {'scope' -> 'global'};
__on_chunk_generated(x, z) -> (
  scan(x,0,z,0,0,0,15,15,15,
    if (perlin(_x/16, _y/8, _z/16) > _y/16,
      set(_, 'black_stained_glass');
    )
  )
)
```

The following addition resolves this issue, by not allowing block updates past chunk borders:

```scarpet
__config() -> {'scope' -> 'global'};
__on_chunk_generated(x, z) -> (
  without_updates(
    scan(x,0,z,0,0,0,15,15,15,
      if (perlin(_x/16, _y/8, _z/16) > _y/16,
        set(_, 'black_stained_glass');
      )
    )
  )
)
```

### `place_item(item, pos, facing?, sneak?)`

Uses a given item in the world like it was used by a player. Item names are default minecraft item name,
less the minecraft prefix. Default facing is 'up', but there are other options: 'down', 'north', 'east', 'south',
'west', but also there are other secondary directions important for placement of blocks like stairs, doors, etc.
Try experiment with options like 'north-up' which is placed facing north with cursor pointing to the upper part of the
block, or 'up-north', which means a block placed facing up (player looking down) and placed smidge away of the block
center towards north. Optional sneak is a boolean indicating if a player would be sneaking while placing the
block - this option only affects placement of chests and scaffolding at the moment.

Works with items that have the right-click effect on the block placed, like `bone_meal` on grass or axes on logs,
but doesn't open chests / containers, so have no effect on interactive blocks, like TNT, comparators, etc.

Returns true if placement/use was
successful, false otherwise.

Throws `unknown_item` if `item` doesn't exist

```scarpet
place_item('stone',x,y,z) // places a stone block on x,y,z block
place_item('piston,x,y,z,'down') // places a piston facing down
place_item('carrot',x,y,z) // attempts to plant a carrot plant. Returns true if could place carrots at that position.
place_item('bone_meal',x,y,z) // attempts to bonemeal the ground.
place_item('wooden_axe',x,y,z) // attempts to strip the log.
```

### `set_poi(pos, type, occupancy?)`

Sets a Point of Interest (POI) of a specified type with optional custom occupancy. By default new POIs are not occupied.
If type is `null`, POI at position is removed. In any case, previous POI is also removed. Available POI types are:

*   `'unemployed', 'armorer', 'butcher', 'cartographer', 'cleric', 'farmer', 'fisherman', 'fletcher', 'leatherworker', 'librarian', 'mason', 'nitwit', 'shepherd', 'toolsmith', 'weaponsmith', 'home', 'meeting', 'beehive', 'bee_nest', 'nether_portal'`

Interestingly, `unemployed`, and `nitwit` are not used in the game, meaning, they could be used as permanent spatial
markers for scarpet apps. `meeting` is the only one with increased max occupancy of 32.

Throws `unknown_poi` if the provided point of interest doesn't exist

### `set_biome(pos, biome_name, update=true)`

Changes the biome at that block position. if update is specified and false, then chunk will not be refreshed
on the clients. Biome changes can only be sent to clients with the entire data from the chunk.

Be aware that depending on the MC version and dimension settings biome can be set either in a 1x1x256
column or 4x4x4 hyperblock, so for some versions Y will be ignored and for some precision of biome
setting is less than 1x1x1 block.

Throws `unknown_biome` if the `biome_name` doesn't exist.

### `update(pos)`

Causes a block update at position.

### `block_tick(pos)`

Causes a block to tick at position.

### `random_tick(pos)`

Causes a random tick at position.

### `destroy(pos), destroy(pos, -1), destroy(pos, <N>), destroy(pos, tool, nbt?)`

Destroys the block like it was mined by a player. Add -1 for silk touch, and a positive number for fortune level.
If tool is specified, and optionally its nbt, it will use that tool and will attempt to mine the block with this tool.
If called without item context, this function, unlike harvest, will affect all kinds of blocks. If called with item
in context, it will fail to break blocks that cannot be broken by a survival player.

Without item context it returns `false` if failed to destroy the block and `true` if block breaking was successful.
In item context, `true` means that breaking item has no nbt to use, `null` indicating that the tool should be
considered broken in process, and `nbt` type value, for a resulting NBT tag on a hypothetical tool. Its up to the
programmer to use that nbt to apply it where it belong

Throws `unknown_item` if `tool` doesn't exist.

Here is a sample code that can be used to mine blocks using items in player inventory, without using player context
for mining. Obviously, in this case the use of `harvest` would be much more applicable:

```scarpet
mine(x,y,z) ->
(
  p = player();
  slot = p~'selected_slot';
  item_tuple = inventory_get(p, slot);
  if (!item_tuple, destroy(x,y,z,'air'); return()); // empty hand, just break with 'air'
  [item, count, tag] = item_tuple;
  tag_back = destroy(x,y,z, item, tag);
  if (tag_back == false, // failed to break the item
    return(tag_back)
  );
  if (tag_back == true, // block broke, tool has no tag
    return(tag_back)
  );
  if (tag_back == null, //item broke
    delete(tag:'Damage');
    inventory_set(p, slot, count-1, item, tag);
    return(tag_back)
  );
  if (type(tag_back) == 'nbt', // item didn't break, here is the effective nbt
    inventory_set(p, slot, count, item, tag_back);
    return(tag_back)
  );
  print('How did we get here?');
)
```

### `harvest(player, pos)`

Causes a block to be harvested by a specified player entity. Honors player item enchantments, as well as damages the
tool if applicable. If the entity is not a valid player, no block gets destroyed. If a player is not allowed to break
that block, a block doesn't get destroyed either.

### `create_explosion(pos, power?, mode?, fire?, source?, attacker?)`

Creates an explosion at a given position. Parameters work as follows:
 - `'power'` - how strong the blast is, negative values count as 0 (default: `4` (TNT power))
 - `'mode'` - how to deal with broken blocks: `keep` keeps them, `destroy` destroys them and drops items, and `destroy_with_decay` destroys them, but doesn't always drop the items (default: `destroy_with_decay`)
 - `fire` - whether extra fire blocks should be created (default: `false`)
 - `source` - entity that is exploding. Note that it will not take explosion damage from this explosion (default: `null`)
 - `attacker` - entity responsible for triggering, this will be displayed in death messages, and count towards kill counts, and can be damaged by the explosion (default: `null`)
Explosions created with this endpoint cannot be captured with `__on_explosion` event, however they will be captured
by `__on_explosion_outcome`.

### `weather()`,`weather(type)`,`weather(type, ticks)`

If called with no args, returns `'clear'`, `'rain` or `'thunder'` based on the current weather. If thundering, will
always return `'thunder'`, if not will return `'rain'` or `'clear'` based on the current weather.

With one arg, (either `'clear'`, `'rain` or `'thunder'`), returns the number of remaining ticks for that weather type.
NB: It can thunder without there being a thunderstorm; there has to be both rain and thunder to form a storm. So if
running `weather()` returns `'thunder'`, you can use `weather('rain')>0` to see if there's a storm going on.

With two args, sets the weather to the given `type` for `ticks` ticks.

## Block and World querying

### `pos(block), pos(entity)`

Returns a triple of coordinates of a specified block or entity. Technically entities are queried with `query` function
and the same can be achieved with `query(entity,'pos')`, but for simplicity `pos` allows to pass all positional objects.

```scarpet
pos(block(0,5,0)) => [0,5,0]
pos(player()) => [12.3, 45.6, 32.05]
pos(block('stone')) => Error: Cannot fetch position of an unrealized block
```

### `pos_offset(pos, direction, amount?)`

Returns a coords triple that is offset in a specified `direction` by `amount` of blocks. The default offset amount is
1 block. To offset into opposite facing, use negative numbers for the `amount`.

```scarpet
pos_offset(block(0,5,0), 'up', 2)  => [0,7,0]
pos_offset([0,5,0], 'up', -2 ) => [0,3,0]
```

### `block_properties(pos)`

Deprecated by `keys(block_state(pos))`.

### `property(pos, name)`

Deprecated by `block_state(pos, name)`

### `block_state(block)`, `block_state(block, property)`

If used with a `block` argument only, it returns a map of block properties and their values.  If a block has no properties, returns an
empty map.

If `property` is specified, returns a string value of that property, or `null` if property is not applicable.

Returned values or properties are always strings. It is expected from the user to know what to expect and convert
values to numbers using `number()` function or booleans using `bool()` function. Returned string values can be directly used
back in state definition in various applications where block properties are required.

`block_state` can also accept block names as input, returning block's default state.

Throws `unknown_block` if the provided input is not valid.

```scarpet
set(x,y,z,'iron_block'); block_state(x,y,z)  => {}
set(x,y,z,'iron_trapdoor','half','top'); block_state(x,y,z)  => {waterlogged: false, half: top, open: false, ...}
set(x,y,z,'iron_trapdoor','half','top'); block_state(x,y,z,'half')  => top
block_state('iron_trapdoor','half')  => top
set(x,y,z,'air'); block_state(x,y,z,'half')  => null
block_state(block('iron_trapdoor[half=top]'),'half')  => top
block_state(block('iron_trapdoor[half=top]'),'powered')  => false
bool(block_state(block('iron_trapdoor[half=top]'),'powered'))  => 0
```

### `block_list()`, `block_list(tag)`

Returns list of all blocks in the game. If `tag` is provided, returns list of all blocks that belong to this block tag.
```scarpet
block_list() => [dark_oak_button, wall_torch, structure_block, polished_blackstone_brick_slab, cherry_sapling... ]
block_list('impermeable') => [glass, white_stained_glass, orange_stained_glass, magenta_stained_glass... ] //All da glass
block_list('rails') => [rail, powered_rail, detector_rail, activator_rail]
block_list('not_a_valid_block_tag') => null //Not a valid block tag
```


### `block_tags()`, `block_tags(block)`, `block_tags(block, tag)`

Without arguments, returns list of available tags, with block supplied (either by coordinates, or via block name), returns lost
of tags the block belongs to, and if a tag is specified, returns `null` if tag is invalid, `false` if this block doesn't belong
to this tag, and `true` if the block belongs to the tag.

Throws `unknown_block` if `block` doesn't exist

```scarpet
block_tags() => [geode_invalid_blocks, wall_post_override, ice, wooden_stairs, bamboo_blocks, stone_bricks... ]
block_tags('iron_block') => [mineable/pickaxe, needs_stone_tool, beacon_base_blocks]
block_tags('glass') => [impermeable]
block_tags('glass', 'impermeable') => true
block_tags('glass', 'beacon_base_blocks') => false
```

### `block_data(pos)`

Return NBT string associated with specific location, or null if the block does not carry block data. Can be currently
used to match specific information from it, or use it to copy to another block

```scarpet
block_data(x,y,z) => '{TransferCooldown:0,x:450,y:68, ... }'
```

### `poi(pos), poi(pos, radius?, type?, status?, column_search?)`

Queries a POI (Point of Interest) at a given position, returning `null` if none is found, or tuple of poi type and its
occupancy load. With optional `type`, `radius` and `status`, returns a list of POIs around `pos` within a
given `radius`. If the `type` is specified, returns only poi types of that types, or everything if omitted or `'any'`.
If `status` is specified (either `'any'`, `'available'`, or `'occupied'`) returns only POIs with that status.
With `column_search` set to `true`, it will return all POIs in a cuboid with `radius` blocks away on x and z, in the entire
block column from 0 to 255. Default (`false`) returns POIs within a spherical area centered on `pos` and with `radius`
radius.

All results of `poi` calls are returned in sorted order with respect to the euclidean distance to the requested center of `pos`.

The return format of the results is a list of poi type, occupancy load, and extra triple of coordinates.

Querying for POIs using the radius is the intended use of POI mechanics, and the ability of accessing individual POIs
via `poi(pos)` in only provided for completeness.

```scarpet
poi(x,y,z) => null  // nothing set at position
poi(x,y,z) => ['meeting',3]  // its a bell-type meeting point occupied by 3 villagers
poi(x,y,z,5) => []  // nothing around
poi(x,y,z,5) => [['nether_portal',0,[7,8,9]],['nether_portal',0,[7,9,9]]] // two portal blocks in the range
```

### `biome()` `biome(name)` `biome(block)` `biome(block/name, feature)`, `biome(noise_map)`

Without arguments, returns the list of biomes in the world.

With block, or name, returns the name of the biome in that position, or throws `'unknown_biome'` if provided biome or block are not valid.

(1.18+) if passed a map of `continentalness`, `depth`, `erosion`, `humidity`, `temperature`, `weirdness`, returns the biome that exists at those noise values.
Note: Have to pass all 6 of the mentioned noise types and only these noise types for it to evaluate a biome.

With an optional feature, it returns value for the specified attribute for that biome. Available and queryable features include:
* `'top_material'`: unlocalized block representing the top surface material (1.17.1 and below only)
* `'under_material'`: unlocalized block representing what sits below topsoil (1.17.1 and below only)
* `'category'`: the parent biome this biome is derived from. Possible values include (1.18.2 and below only):
`'none'`, `'taiga'`, `'extreme_hills'`, `'jungle'`, `'mesa'`, `'plains'`, `'savanna'`,
`'icy'`, `'the_end'`, `'beach'`, `'forest'`, `'ocean'`, `'desert'`, `'river'`,
`'swamp'`, `'mushroom'` , `'nether'`, `'underground'` (1.18+) and `'mountain'` (1.18+).
* `'tags'`: list of biome tags associated with this biome
* `'temperature'`: temperature from 0 to 1
* `'fog_color'`: RGBA color value of fog
* `'foliage_color'`: RGBA color value of foliage
* `'sky_color'`: RGBA color value of sky
* `'water_color'`: RGBA color value of water
* `'water_fog_color'`: RGBA color value of water fog
* `'humidity'`: value from 0 to 1 indicating how wet is the biome
* `'precipitation'`: `'rain'` `'snot'`, or `'none'`... ok, maybe `'snow'`, but that means snots for sure as well.
* `'depth'`: (1.17.1 and below only) float value indicating how high or low the terrain should generate. Values > 0 indicate generation above sea level
and values < 0, below sea level.
* `'scale'`: (1.17.1 and below only) float value indicating how flat is the terrain.
* `'features'`: list of features that generate in the biome, grouped by generation steps
* `'structures'`: (1.17.1 and below only) list of structures that generate in the biome.

### `solid(pos)`

Boolean function, true if the block is solid.

### `air(pos)`

Boolean function, true if a block is air... or cave air... or void air... or any other air they come up with.

### `liquid(pos)`

Boolean function, true if the block is liquid, or waterlogged (with any liquid).

### `flammable(pos)`

Boolean function, true if the block is flammable.

### `transparent(pos)`

Boolean function, true if the block is transparent.

### `opacity(pos)`

Numeric function, returning the opacity level of a block.

### `blocks_daylight(pos)`

Boolean function, true if the block blocks daylight.

### `emitted_light(pos)`

Numeric function, returning the light level emitted from the block.

### `light(pos)`

Numeric function, returning the total light level at position.

### `block_light(pos)`

Numeric function, returning the block light at position (from torches and other light sources).

### `sky_light(pos)`

Numeric function, returning the sky light at position (from sky access).

### `effective_light(pos)`

Numeric function, returning the "real" light at position, which is affected by time and weather. which also affects mobs spawning, frosted ice blocks melting.

### `see_sky(pos)`

Boolean function, returning true if the block can see sky.

### `hardness(pos)`

Numeric function, indicating hardness of a block.

### `blast_resistance(pos)`

Numeric function, indicating blast_resistance of a block.

### `in_slime_chunk(pos)`

Boolean indicating if the given block position is in a slime chunk.

### `top(type, pos)`

Returns the Y value of the topmost block at given x, z coords (y value of a block is not important), according to the
heightmap specified by `type`. Valid options are:

*   `light`: topmost light blocking block (1.13 only)
*   `motion`: topmost motion blocking block
*   `terrain`: topmost motion blocking block except leaves
*   `ocean_floor`: topmost non-water block
*   `surface`: topmost surface block

```scarpet
top('motion', x, y, z)  => 63
top('ocean_floor', x, y, z)  => 41
```

### `suffocates(pos)`

Boolean function, true if the block causes suffocation.

### `power(pos)`

Numeric function, returning redstone power level at position.

### `ticks_randomly(pos)`

Boolean function, true if the block ticks randomly.

### `blocks_movement(pos)`

Boolean function, true if the block at position blocks movement.

### `block_sound(pos)`

Returns the name of sound type made by the block at position. One of:

`'wood'`, `'gravel'`, `'grass'`, `'stone'`, `'metal'`, `'glass'`, `'wool'`, `'sand'`, `'snow'`,
`'ladder'`, `'anvil'`, `'slime'`, `'sea_grass'`, `'coral'`, `'bamboo'`', `'shoots'`', `'scaffolding'`', `'berry'`', `'crop'`',
`'stem'`', `'wart'`',
`'lantern'`', `'fungi_stem'`', `'nylium'`', `'fungus'`', `'roots'`', `'shroomlight'`', `'weeping_vines'`', `'soul_sand'`',
 `'soul_soil'`', `'basalt'`',
`'wart'`', `'netherrack'`', `'nether_bricks'`', `'nether_sprouts'`', `'nether_ore'`', `'bone'`', `'netherite'`', `'ancient_debris'`',
`'lodestone'`', `'chain'`', `'nether_gold_ore'`', `'gilded_blackstone'`',
`'candle'`', `'amethyst'`', `'amethyst_cluster'`', `'small_amethyst_bud'`', `'large_amethyst_bud'`', `'medium_amethyst_bud'`',
`'tuff'`', `'calcite'`', `'copper'`'

### `material(pos)`

Returns `'unknown'`. The concept of material for blocks is removed. On previous versions it returned the name of the material the block
was made of.

### `map_colour(pos)`

Returns the map colour of a block at position. One of:

`'air'`, `'grass'`, `'sand'`, `'wool'`, `'tnt'`, `'ice'`, `'iron'`, `'foliage'`, `'snow'`, `'clay'`, `'dirt'`,
`'stone'`, `'water'`, `'wood'`, `'quartz'`, `'adobe'`, `'magenta'`, `'light_blue'`, `'yellow'`, `'lime'`, `'pink'`,
`'gray'`, `'light_gray'`, `'cyan'`, `'purple'`, `'blue'`, `'brown'`, `'green'`, `'red'`, `'black'`, `'gold'`,
`'diamond'`, `'lapis'`, `'emerald'`, `'obsidian'`, `'netherrack'`, `'white_terracotta'`, `'orange_terracotta'`,
`'magenta_terracotta'`, `'light_blue_terracotta'`, `'yellow_terracotta'`, `'lime_terracotta'`, `'pink_terracotta'`,
`'gray_terracotta'`, `'light_gray_terracotta'`, `'cyan_terracotta'`, `'purple_terracotta'`, `'blue_terracotta'`,
`'brown_terracotta'`, `'green_terracotta'`, `'red_terracotta'`, `'black_terracotta'`,
`'crimson_nylium'`, `'crimson_stem'`, `'crimson_hyphae'`, `'warped_nylium'`, `'warped_stem'`, `'warped_hyphae'`, `'warped_wart'`

### `sample_noise()`, `sample_noise(pos, ... types?)` 1.18+

Samples the world generation noise values / data driven density function(s) at a given position.

If no types are passed in, or no arguments are given, it returns a list of all the available registry defined density functions.

With a single function name passed in, it returns a scalar. With multiple function names passed in, it returns a list of results.

Function accepts any registry defined density functions, both built in, as well as namespaced defined in datapacks.
On top of that, scarpet provides the following list of noises sampled directly from the current level (and not returned with no-argument call):


`'barrier_noise'`, `'fluid_level_floodedness_noise'`, `'fluid_level_spread_noise'`, `'lava_noise'`,
`'temperature'`, `'vegetation'`, `'continents'`, `'erosion'`, `'depth'`, `'ridges'`,
`'initial_density_without_jaggedness'`, `'final_density'`, `'vein_toggle'`, `'vein_ridged'` and `'vein_gap'`

```scarpet
// requesting single value
sample_density(pos, 'continents') => 0.211626790923
// passing type as multiple arguments
sample_density(pos, 'continents', 'depth', 'overworld/caves/pillars', 'mydatapack:foo/my_function') => [-0.205013844481, 1.04772473438, 0.211626790923, 0.123]
```

### `loaded(pos)`

Boolean function, true if the block is accessible for the game mechanics. Normally `scarpet` doesn't check if operates
on loaded area - the game will automatically load missing blocks. We see this as an advantage. Vanilla `fill/clone`
commands only check the specified corners for loadness.

To check if a block is truly loaded, I mean in memory, use `generation_status(x) != null`, as chunks can still be loaded
outside of the playable area, just are not used by any of the game mechanic processes.

```scarpet
loaded(pos(player()))  => 1
loaded(100000,100,1000000)  => 0
```

### `loaded_ep(pos)`

Boolean function, true if the block is loaded and entity processing, as per 1.13.2

Deprecated as of scarpet 1.6, use `loaded_status(x) > 0`, or just `loaded(x)` with the same effect

### `loaded_status(pos)`

Returns loaded status as per new 1.14 chunk ticket system, 0 for inaccessible, 1 for border chunk, 2 for redstone ticking,
3 for entity ticking

### `is_chunk_generated(pos)`, `is_chunk_generated(pos, force)`

Returns `true` if the region file for the chunk exists,
`false` otherwise. If optional force is `true` it will also check if the chunk has a non-empty entry in its region file
Can be used to assess if the chunk has been touched by the game or not.

`generation_status(pos, false)` only works on currently loaded chunks, and `generation_status(pos, true)` will create
an empty loaded chunk, even if it is not needed, so `is_chunk_generated` can be used as a efficient proxy to determine
if the chunk physically exists.

Running `is_chunk_generated` is has no effects on the world, but since it is an external file operation, it is
considerably more expensive (unless area is loaded) than other generation and loaded checks.

### `generation_status(pos), generation_status(pos, true)`

Returns generation status as per the ticket system. Can return any value from several available but chunks
can only be stable in a few states: `full`, `features`, `liquid_carvers`, and `structure_starts`. Returns `null`
if the chunk is not in memory unless called with optional `true`.

### `inhabited_time(pos)`

Returns inhabited time for a chunk.

### `spawn_potential(pos)`

Returns spawn potential at a location (1.16+ only)

### `reload_chunk(pos)`

Sends full chunk data to clients. Useful when lots stuff happened and you want to refresh it on the clients.

### `reset_chunk(pos)`, `reset_chunk(from_pos, to_pos)`, `reset_chunk([pos, ...])`
Removes and resets the chunk, all chunks in the specified area or all chunks in a list at once, removing all previous
blocks and entities, and replacing it with a new generation. For all currently loaded chunks, they will be brought
to their current generation status, and updated to the player. All chunks that are not in the loaded area, will only
be generated to the `'structure_starts'` status, allowing to generate them fully as players are visiting them.
Chunks in the area that has not been touched yet by the game will not be generated / regenerated.

It returns a `map` with a report indicating how many chunks were affected, and how long each step took:
 * `requested_chunks`: total number of chunks in the requested area or list
 * `affected_chunks`: number of chunks that will be removed / regenerated
 * `loaded_chunks`: number of currently loaded chunks in the requested area / list
 * `relight_count`: number of relit chunks
 * `relight_time`: time took to relit chunks
 * `layer_count_<status>`: number of chunks for which a `<status>` generation step has been performed
 * `layer_time_<status>`: cumulative time for all chunks spent on generating `<status>` step

### `add_chunk_ticket(pos, type, radius)`

Adds a chunk ticket at a position, which makes the game to keep the designated area centered around
`pos` with radius of `radius` loaded for a predefined amount of ticks, defined by `type`. Allowed types
are `portal`: 300 ticks, `teleport`: 5 ticks, and `unknown`: 1 tick. Radius can be from 1 to 32 ticks.

This function is tentative - will likely change when chunk ticket API is properly fleshed out.

### `structure_eligibility(pos, ?structure, ?size_needed)`

Checks worldgen eligibility for a structure in a given chunk. Requires a `Structure Variant` name (see above),
or `Standard Structure` to check structures of this type.
If no structure is given, or `null`, then it will check
for all structures. If bounding box of the structures is also requested, it will compute size of potential
structures. This function, unlike other in the `structure*` category is not using world data nor accesses chunks
making it preferred for scoping ungenerated terrain, but it takes some compute resources to calculate the structure.

Unlike `'structure'` this will return a tentative structure location. Random factors in world generation may prevent
the actual structure from forming.

If structure is specified, it will return `null` if a chunk is not eligible or invalid, `true` if the structure should appear, or
a map with two values: `'box'` for a pair of coordinates indicating bounding box of the structure, and `'pieces'` for
list of elements of the structure (as a tuple), with its name, direction, and box coordinates of the piece.

If structure is not specified, or a `Standard Structure` was specified, like `'village'`,it will return a set of structure names that are eligible, or a map with structures
as keys, and same type of map values as with a single structure call. An empty set or an empty map would indicate that nothing
should be generated there.

Throws `unknown_structure` if structure doesn't exist.

### `structures(pos), structures(pos, structure_name)`

Returns structure information for a given block position. Note that structure information is the same for all the
blocks from the same chunk. `structures` function can be called with a block, or a block and a structure name. In
the first case it returns a map of structures at a given position, keyed by structure name, with values indicating
the bounding box of the structure - a pair of two 3-value coords (see examples). When called with an extra structure
name, returns a map with two values, `'box'` for bounding box of the structure, and `'pieces'` for a list of
components for that structure, with their name, direction and two sets of coordinates
indicating the bounding box of the structure piece. If structure is invalid, its data will be `null`.

Requires a `Standard Structure` name (see above).

### `structure_references(pos), structure_references(pos, structure_name)`

Returns structure information that a chunk with a given block position is part of. `structure_references` function
can be called with a block, or a block and a structure name. In the first case it returns a list of structure names
that give chunk belongs to. When called with an extra structure name, returns list of positions pointing to the
lowest block position in chunks that hold structure starts for these structures. You can query that chunk structures
then to get its bounding boxes.

Requires a `Standard Structure` name (see above).

### `set_structure(pos, structure_name), set_structure(pos, structure_name, null)`

Creates or removes structure information of a structure associated with a chunk of `pos`. Unlike `plop`, blocks are
not placed in the world, only structure information is set. For the game this is a fully functional structure even
if blocks are not set. To remove the structure a given point is in, use `structure_references` to find where current
structure starts.

Requires a `Structure Variant` or `Standard Structure` name (see above). If standard name is used, the variant of the
structure may depend on the biome, otherwise the default structure for this type will be generated.

Throws `unknown_structure` if structure doesn't exist.

### `plop(pos, what)`

Plops a structure or a feature at a given `pos`, so block, triple position coordinates or a list of coordinates.
To `what` gets plopped and exactly where it often depends on the feature or structure itself.

Requires a `Structure Type`,  `Structure`, `World Generation Feature` or `Custom Scarpet Feature` name (see
above). If standard name is used, the variant of the structure may depend on the biome, otherwise the default
structure for this type will be generated.

All structures are chunk aligned, and often span multiple chunks. Repeated calls to plop a structure in the same chunk
would result either in the same structure generated on top of each other, or with different state, but same position.
Most structures generate at specific altitudes, which are hardcoded, or with certain blocks around them. API will
cancel all extra position / biome / random requirements for structure / feature placement, but some hardcoded
limitations may still cause some of structures/features not to place. Some features require special blocks to be
present, like coral -> water or ice spikes -> snow block, and for some features, like fossils, placement is all sorts
of messed up. This can be partially avoided for structures by setting their structure information via `set_structure`,
which sets it without looking into world blocks, and then use `plop` to fill it with blocks. This may, or may not work.

All generated structures will retain their properties, like mob spawning, however in many cases the world / dimension
itself has certain rules to spawn mobs, like plopping a nether fortress in the overworld will not spawn nether mobs,
because nether mobs can spawn only in the nether, but plopped in the nether - will behave like a valid nether fortress.
# Iterating over larger areas of blocks

These functions help scan larger areas of blocks without using generic loop functions, like nested `loop`.

### `scan(center, range, upper_range?, expr)`

Evaluates expression over area of blocks defined by its center `center = (cx, cy, cz)`, expanded in all directions
by `range = (dx, dy, dz)` blocks, or optionally in negative with `range` coords, and `upper_range` coords in
positive values. That means that if you want a box starting at the northwest coord with given base, width and height
dimensions, you can do `'scan(center, 0, 0, 0, w, h, d, ...)`.

`center` can be defined either as three coordinates, a single tuple of three coords, or a block value.
`range` and `upper_range` can have the same representations, just if they are block values, it computes the distance to
the center as range instead of taking the values as is. That way you can iterate from the center to a box whose surface
area constains the `range` and/or `upper_range` blocks.

`expr` receives `_x, _y, _z` variables as coords of current analyzed block and `_`, which represents the block itself.

Returns number of successful evaluations of `expr` (with `true` boolean result) unless called in void context,
which would cause the expression not be evaluated for their boolean value.

`scan` also handles `continue` and `break` statements, using `continue`'s return value to use in place of expression
return value. `break` return value has no effect.

### `volume(from_pos, to_pos, expr)`

Evaluates expression for each block in the area, the same as the `scan` function, but using two opposite corners of
the rectangular cuboid. Any corners can be specified, its like you would do with `/fill` command.
You can use a position or three coordinates to specify, it doesn't matter.

For return value and handling `break` and `continue` statements, see `scan` function above.

### `neighbours(pos)`

Returns the list of 6 neighbouring blocks to the argument. Commonly used with other loop functions like `for`.

```scarpet
for(neighbours(x,y,z),air(_)) => 4 // number of air blocks around a block
```

### `rect(center, range?, upper_range?)`

Returns an iterator, just like `range` function that iterates over a rectangular area of blocks. If only center
point is specified, it iterates over 27 blocks (range of 1). If `range` arguments are specified, expands selection by
the respective number of blocks in each direction. If `upper_range` arguments are specified, it uses `range` for
negative offset, and `upper_range` for positive, similar to `scan`.

Basically the arguments are the same as the first three arguments of `scan`, except this function returns the list of
blocks that `scan` would evaluate over. If you are going to iterate over these blocks, like `for(rect(args), do_something())`,
then `scan(args, do_something())` is an equivalent, yet more compute-friendly alternative, especially for very large areas.

`center` can be defined either as three coordinates, a list of three coords, or a block value.
`range` and `upper_range` can have the same representations, just if they are block values, it computes the distance to the center
as range instead of taking the values as is.`

### `diamond(center_pos, radius?, height?)`

Iterates over a diamond like area of blocks. With no radius and height, its 7 blocks centered around the middle
(block + neighbours). With a radius specified, it expands shape on x and z coords, and with a custom height, on y.
Any of these can be zero as well. radius of 0 makes a stick, height of 0 makes a diamond shape pad.

If radius and height are the same, creats a 3D diamond, of all the blocks which are a manhattan distance of `radius` away
from the center.

### `player(), player(type), player(name)`

With no arguments, it returns the calling player or the player closest to the caller.
For player-scoped apps (which is a default) its always the owning player or `null` if it not present even if some code
still runs in their name.
Note that the main context
will receive `p` variable pointing to this player. With `type` or `name` specified, it will try first to match a type,
returning a list of players matching a type, and if this fails, will assume its player name query retuning player with
that name, or `null` if no player was found. With `'all'`, list of all players in the game, in all dimensions, so end
user needs to be cautious, that you might be referring to wrong blocks and entities around the player in question.
With `type = '*'` it returns all players in caller dimension, `'survival'` returns all survival and adventure players,
`'creative'` returns all creative players, `'spectating'` returns all spectating players, and `'!spectating'`,
all not-spectating players. If all fails, with `name`, the player in question, if he/she is logged in.

### `entity_id(uuid), entity_id(id)`

Fetching entities either by their ID obtained via `entity ~ 'id'`, which is unique for a dimension and current world
run, or by UUID, obtained via `entity ~ 'uuid'`. It returns null if no such entity is found. Safer way to 'store'
entities between calls, as missing entities will be returning `null`. Both calls using UUID or numerical ID are `O(1)`,
but obviously using UUIDs takes more memory and compute.

### `entity_list(descriptor)`

Returns global lists of entities in the current dimension matching specified descriptor.
Calls to `entity_list` always fetch entities from the current world that the script executes.

### `entity_types(descriptor)`

Resolves a given descriptor returning list of entity types that match it. The returned list of types is also a valid list
of descriptors that can be use elsewhere where entity types are required.

Currently, the following descriptors are available:

*  `*`: all entities, even `!valid`, matches all entity types.
*  `valid` - all entities that are not dead (health > 0). All main categories below also return only
entities in the `valid` category. matches all entity types. `!valid` matches all entites that are already dead of all types.
*  `living` - all entities that resemble a creature of some sort
*  `projectile` - all entities or types that are not living that can be throw or projected, `!projectile` matches all types that
   are not living, but cannot the thrown or projected.
*  `minecarts` matches all minecart types. `!minecarts` matches all types that are not live, but also not minecarts. Using plural
since `minecart` is a proper entity type on its own.
*  `undead`, `arthropod`, `aquatic`, `regular`, `illager` - all entities / types that belong to any of these groups. All
living entities belong to one and only one of these. Corresponding negative (e.g. `!undead`) corresponds to all mobs that are
living but don't belong to that group. Entity groups are used in interaction / battle mechanics like smite for undead, or impaling
for aquatic. Also certain mechanics interact with groups, like ringing a bell with illagers. All other mobs that don't have any of these traits belong
to the `regular` group.
*  `monster`, `creature`, `ambient`, `water_creature`, `water_ambient`, `misc` - another categorization of
living entities based on their spawn group. Negative descriptor resolves to all living types that don't belong to that
category.
* All entity tags including those provided with datapacks. Built-in entity tags include: `skeletons`, `raiders`,
`beehive_inhabitors` (bee, duh), `arrows` and `impact_projectiles`.
* Any of the standard entity types, equivalent to selection from `/summon` vanilla command, which is one of the options returned
by `entity_types()`, except for `'fishing_bobber'` and `'player'`.

All categories can be preceded with `'!'` which will fetch all entities (unless otherwise noted) that are valid (health > 0) but not
belonging to that group.

### `entity_area(type, center, distance)`


Returns entities of a specified type in an area centered on `center` and at most `distance` blocks away from
the center point/area. Uses the same `type` selectors as `entities_list`.

`center` and `distance` can either be a triple of coordinates or three consecutive arguments for `entity_area`. `center` can
also be represented as a block, in this case the search box will be centered on the middle of the block, or an entity - in this case
entire bounding box of the entity serves as a 'center' of search which is then expanded in all directions with the `'distance'` vector.

In any case - returns all entities which bounding box collides with the bounding box defined by `'center'` and `'distance'`.

entity_area is simpler than `entity_selector` and runs about 20% faster, but is limited to predefined selectors and
cuboid search area.

### `entity_selector(selector)`

Returns entities satisfying given vanilla entity selector. Most complex among all the methods of selecting entities,
but the most capable. Selectors are cached so it should be as fast as other methods of selecting entities. Unlike other
entities fetching / filtering method, this one doesn't guarantee to return entities from current dimension, since
selectors can return any loaded entity in the world.

### `spawn(name, pos, nbt?)`

Spawns and places an entity in world, like `/summon` vanilla command. Requires a position to spawn, and optional
extra nbt data to merge with the entity. What makes it different from calling `run('summon ...')`, is the fact that
you get the entity back as a return value, which is swell.

### `entity_load_handler(descriptor / descriptors, function)`, `entity_load_handler(descriptor / descriptors, call_name, ... args?)`

Attaches a callback to trigger when any entity matching the following type / types is loaded in the game, allowing to grab a handle
to an entity right when it is loaded to the world without querying them every tick. Callback expects two parameters - the entity,
and a boolean value indicating if the entity was newly created(`true`) or just loaded from disk. Single argument functions accepting
only entities are allowed, but deprecated and will be removed at some point.

If callback is `null`, then the current entity handler, if present, is removed. Consecutive calls to `entity_load_handler` will add / subtract
of the currently targeted entity types pool.

Like other global events, calls to `entity_load_handler` should only be attached in apps with global scope. For player scope apps,
it will be called multiple times, once for each player. That's likely not what you want to do.

```
// veryfast method of getting rid of all the zombies. Callback is so early, its packets haven't reached yet the clients
// so to save on log errors, removal of mobs needs to be scheduled for later.
entity_load_handler('zombie', _(e, new) -> schedule(0, _(outer(e)) -> modify(e, 'remove')))

// another way to do it is to remove the entity when it starts ticking
entity_load_handler('zombie', _(e, new) -> entity_event(e, 'on_tick', _(e) -> modify(e, 'remove')))

// making all zombies immediately faster and less susceptible to friction of any sort
entity_load_handler('zombie', _(e, new) -> entity_event(e, 'on_tick', _(e) -> modify(e, 'motion', 1.2*e~'motion')))
```

Word of caution: entities can be loaded with chunks in various states, for instance when a chunk is being generated, this means
that accessing world blocks would cause the game to freeze due to force generating that chunk while generating the chunk. Make
sure to never assume the chunk is ready and use `entity_load_handler` to schedule actions around the loaded entity,
or manipulate entity directly.

Also, it is possible that mobs that spawn with world generation, while being 'added' have their metadata serialized and cached
internally (vanilla limitation), so some modifications to these entities may have no effect on them. This affects mobs created with
world generation.

For instance the following handler is safe, as it only accesses the entity directly. It makes all spawned pigmen jump
```
/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, modify(e, 'motion', 0, 1, 0)) )
```
But the following handler, attempting to despawn pigmen that spawn in portals, will cause the game to freeze due to cascading access to blocks that would cause neighbouring chunks
to force generate, causing also error messages for all pigmen caused by packets send after entity is removed by script.
```
/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new && block(pos(e))=='nether_portal', modify(e, 'remove') ) )
```
Easiest method to circumvent these issues is delay the check, which may or may not cause cascade load to happen, but
will definitely break the infinite chain.
```
/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, schedule(0, _(outer(e)) -> if(block(pos(e))=='nether_portal', modify(e, 'remove') ) ) ) )
```
But the best is to perform the check first time the entity will be ticked - giving the game all the time to ensure chunk
is fully loaded and entity processing, removing the tick handler:
```
/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, entity_event(e, 'on_tick', _(e) -> ( if(block(pos(e))=='nether_portal', modify(e, 'remove')); entity_event(e, 'on_tick', null) ) ) ) )
```
Looks little convoluted, but that's the safest method to ensure your app won't crash.

### `entity_event(e, event, function)`, `entity_event(e, event, call_name, ... args?)`

Attaches specific function from the current package to be called upon the `event`, with extra `args` carried to the
original required arguments for the event handler.

```scarpet
protect_villager(entity, amount, source, source_entity, healing_player) ->
(
   if(source_entity && source_entity~'type' != 'player',
      modify(entity, 'health', amount + entity~'health' );
      particle('end_rod', pos(entity)+[0,3,0]);
      print(str('%s healed thanks to %s', entity, healing_player))
   )
);
__on_player_interacts_with_entity(player, entity, hand) ->
(
   if (entity~'type' == 'villager',
      entity_event(entity, 'on_damage', 'protect_villager', player~'name')
   )
)
```

In this case this will protect a villager from entity damage (zombies, etc.) except from players by granting all the
health back to the villager after being harmed.

### `item_list(tag?)`

With no arguments, returns a list of all items in the game. With an item tag provided, list items matching the tag, or `null` if tag is not valid.

### `item_tags(item, tag?)`

Returns list of tags the item belongs to, or, if tag is provided, `true` if an item matches the tag, `false` if it doesn't and `null` if that's not a valid tag

Throws `unknown_item` if item doesn't exist.

### `stack_limit(item)`

Returns number indicating what is the stack limit for the item. Its typically 1 (non-stackable), 16 (like buckets),
or 64 - rest. It is recommended to consult this, as other inventory API functions ignore normal stack limits, and
it is up to the programmer to keep it at bay. As of 1.13, game checks for negative numbers and setting an item to
negative is the same as empty.

Throws `unknown_item` if item doesn't exist.

```scarpet
stack_limit('wooden_axe') => 1
stack_limit('ender_pearl') => 16
stack_limit('stone') => 64
```

### `recipe_data(item, type?)`, `recipe_data(recipe, type?)`

returns all recipes matching either an `item`, or represent actual `recipe` name. In vanilla datapack, for all items
that have one recipe available, the recipe name is the same as the item name but if an item has multiple recipes, its
direct name can be different.

Recipe type can take one of the following options:
 * `'crafting'` - default, crafting table recipe
 * `'smelting'` - furnace recipe
 * `'blasting'` - blast furnace recipe
 * `'smoking'` - smoker recipe
 * `'campfire_cooking'` - campfire recipe
 * `'stonecutting'` - stonecutter recipe
 * `'smithing'` - smithing table (1.16+)

 The return value is a list of available recipes (even if there is only one recipe available). Each recipe contains of
 an item triple of the crafting result, list of ingredients, each containing a list of possible variants of the
 ingredients in this slot, as item triples, or `null` if its a shaped recipe and a given slot in the patterns is left
 empty, and recipe specification as another list. Possible recipe specs is:
  * `['shaped', width, height]` - shaped crafting. `width` and `height` can be 1, 2 or 3.
  * `['shapeless']` - shapeless crafting
  * `['smelting', duration, xp]` - smelting/cooking recipes
  * `['cutting']` - stonecutter recipe
  * `['special']` - special crafting recipe, typically not present in the crafting menu
  * `['custom']` - other recipe types

Note that ingredients are specified as tripes, with count and nbt information. Currently all recipes require always one
of the ingredients, and for some recipes, even if the nbt data for the ingredient is specified (e.g. `dispenser`), it
can accept items of any tags.

Also note that some recipes leave some products in the crafting window, and these can be determined using
 `crafting_remaining_item()` function

 Examples:
 ```scarpet
 recipe_data('iron_ingot_from_nuggets')
 recipe_data('iron_ingot')
 recipe_data('glass', 'smelting')
 ```

### `crafting_remaining_item(item)`

returns `null` if the item has no remaining item in the crafting window when used as a crafting ingredient, or an
item name that serves as a replacement after crafting is done. Currently it can only be buckets and glass bottles.

### `inventory_size(inventory)`

Returns the size of the inventory for the entity or block in question. Returns null if the block or entity don't
have an inventory.

```scarpet
inventory_size(player()) => 41
inventory_size('enderchest', player()) => 27 // enderchest
inventory_size('equipment', player()) => 6 // equipment
inventory_size(null, player()) => 41  // default inventory for players

inventory_size(x,y,z) => 27 // chest
inventory_size(block(pos)) => 5 // hopper

horse = spawn('horse', x, y, z);
inventory_size(horse); => 2 // default horse inventory
inventory_size('equipment', horse); => 6 // unused horse equipment inventory
inventory_size(null, horse); => 2 // default horse

creeper = spawn('creeper', x, y, z);
inventory_size(creeper); => 6 // default creeper inventory is equipment since it has no other
inventory_size('equipment', creeper); => 6 // unused horse equipment inventory
inventory_size(null, creeper); => 6 // creeper default is its equipment
```

### `inventory_has_items(inventory)`

Returns true, if the inventory is not empty, false if it is empty, and null, if its not an inventory.

```scarpet    inventory_has_items(player()) => true
    inventory_has_items(x,y,z) => false // empty chest
    inventory_has_items(block(pos)) => null // stone
```

### `inventory_get(inventory, slot)`

Returns the item in the corresponding inventory slot, or null if slot empty or inventory is invalid. You can use
negative numbers to indicate slots counted from 'the back'.

```scarpet
inventory_get(player(), 0) => null // nothing in first hotbar slot
inventory_get(x,y,z, 5) => ['stone', 1, {}]
inventory_get(player(), -1) => ['diamond_pickaxe', 1, {Damage:4}] // slightly damaged diamond pick in the offhand
```

### `inventory_set(inventory, slot, count, item?, nbt?)`

Modifies or sets a stack in inventory. specify count 0 to empty the slot. If item is not specified, keeps existing
item, just modifies the count. If item is provided - replaces current item. If nbt is provided - adds a tag to the
stack at slot. Returns previous stack in that slot.

```scarpet
inventory_set(player(), 0, 0) => ['stone', 64, {}] // player had a stack of stone in first hotbar slot
inventory_set(player(), 0, 6) => ['diamond', 64, {}] // changed stack of diamonds in player slot to 6
inventory_set(player(), 0, 1, 'diamond_axe','{Damage:5}') => null //added slightly damaged diamond axe to first player slot
```

### `inventory_find(inventory, item, start_slot?, ), inventory_find(inventory, null, start_slot?)`

Finds the first slot with a corresponding item in the inventory, or if queried with null: the first empty slot.
Returns slot number if found, or null otherwise. Optional start_slot argument allows to skip all preceeding slots
allowing for efficient (so not slot-by-slot) inventory search for items.

```scarpet
inventory_find(player(), 'stone') => 0 // player has stone in first hotbar slot
inventory_find(player(), null) => null // player's inventory has no empty spot
while( (slot = inventory_find(p, 'diamond', slot)) != null, 41, drop_item(p, slot) )
    // spits all diamonds from player inventory wherever they are
inventory_drop(x,y,z, 0) => 64 // removed and spawned in the world a full stack of items
```

Throws `unknown_item` if item doesn't exist.

### `inventory_remove(inventory, item, amount?)`

Removes amount (defaults to 1) of item from inventory. If the inventory doesn't have the defined amount, nothing
happens, otherwise the given amount of items is removed wherever they are in the inventory. Returns boolean
whether the removal operation was successful. Easiest way to remove a specific item from player inventory
without specifying the slot.

```scarpet
inventory_remove(player(), 'diamond') => 1 // removed diamond from player inventory
inventory_remove(player(), 'diamond', 100) => 0 // player doesn't have 100 diamonds, nothing happened
```

### `drop_item(inventory, slot, amount?, )`

Drops the items from indicated inventory slot, like player that Q's an item or villager, that exchanges food.
You can Q items from block inventories as well. default amount is 0 - which is all from the slot.
NOTE: hoppers are quick enough to pick all the queued items from their inventory anyways.
Returns size of the actual dropped items.

```scarpet
inventory_drop(player(), 0, 1) => 1 // Q's one item on the ground
inventory_drop(x,y,z, 0) => 64 // removed and spawned in the world a full stack of items
```
